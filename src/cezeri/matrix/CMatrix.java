/**
 * B. CMatrix class is a core class of Open Cezeri Library (OCL) and it is
 * implemented by Dr.Musa ATAŞ who is the instructor and principal coordinator
 * at the Department of Computer Engineering and so called El-Cezeri Cybernetics
 * and Vision Laboratory, respectively.
 *
 * Important Remarks(last updated at 04.11.2014)
 *
 * 1- Note that CMatrix is implemented as a Static Factory Design Pattern
 * approach. Therefore you can not build an object directly via the constructor.
 * Rather, instance or object can be generated by calling getInstance methods
 * and its overloaded methods. For example CMatrix obj=new CMatrix() is not
 * working, hence instead of this type of calling convention try to type
 * CMatrix.getInstance(); or any other variants of getInstance.
 *
 * 2- Almost all methods of CMatrix returns CMatrix even if you want to use
 * image processing or any other specialized classes. Users in fact doesn't know
 * which external classes are used and what's the algorithms inside the calling
 * methods.
 *
 * 3- In some cases, especially in the case of deep learning, builder pattern is
 * proposed. As a result, until the build() command CMatrix does not returned
 * from any subsequent builder methods.
 *
 * 4- if you encounter the github push authentication not supported problem
 * try this
 *
 * --locale on some Windows platforms makes netbeans crash. Preffer to use "-J-Duser.language=en -J-Duser.region=US"
 *
 * Find netbeans etc, likely at the C:\Program Files\NetBeans 7.3\etc
 * Open netbeans.conf
 * Find netbeans_default_options
 * Add those options, so: netbeans_default_options="blablabla -J-Duser.language=en -J-Duser.region=US"
 * Save file
 * Restart/start netbeans.
 * https://blogs.oracle.com/tao/entry/set_netbeans_user_interface_language
 *
 */
package cezeri.matrix;

import ai.djl.Model;
import ai.djl.basicdataset.cv.classification.ImageFolder;
import cezeri.deep_learning.ai.djl.examples.denemeler.number_classificiation.Models;
import ai.djl.inference.Predictor;
import ai.djl.metric.Metrics;
import ai.djl.modality.Classifications;
import ai.djl.modality.cv.Image;
import ai.djl.modality.cv.ImageFactory;
import ai.djl.modality.cv.transform.Resize;
import ai.djl.modality.cv.transform.ToTensor;
import ai.djl.modality.cv.translator.ImageClassificationTranslator;
import ai.djl.ndarray.types.Shape;
import ai.djl.nn.Block;
import ai.djl.training.EasyTrain;
import ai.djl.training.Trainer;
import ai.djl.training.TrainingConfig;
import ai.djl.training.TrainingResult;
import ai.djl.training.dataset.RandomAccessDataset;
import ai.djl.training.loss.Loss;
import ai.djl.translate.TranslateException;
import ai.djl.translate.Translator;
import cezeri.call_back_interface.CallBackDataBase;
import cezeri.factory.FactoryCombination;
import cezeri.factory.FactoryMatrix;
import cezeri.types.TMatrixOperator;
import cezeri.types.TMatrixCell;
import cezeri.machine_learning.extraction.FeatureExtractionLBP;
import cezeri.machine_learning.extraction.FeatureExtractionPistachio;
import cezeri.machine_learning.extraction.FeatureExtractionRingProjection;
import cezeri.gui.FrameBar;
import cezeri.gui.FrameDataGrid;
import cezeri.gui.FrameHeatMap;
import cezeri.gui.FrameHistogram;
import cezeri.gui.FramePlot;
import cezeri.gui.FrameScatterPlot;
import cezeri.gui.FrameImageHistogram;
import cezeri.gui.FrameImage;
import cezeri.types.TFigureAttribute;
import cezeri.image_processing.GrayScale;
import cezeri.image_processing.ImageProcess;
import cezeri.image_processing.SobelEdgeDetector;
import cezeri.utils.ReaderCSV;
import cezeri.factory.FactoryNormalization;
import cezeri.factory.FactoryPermutation;
import cezeri.factory.FactorySocket;
import cezeri.factory.FactoryUtils;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
//import java.awt.Shape;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFrame;
import org.opencv.core.Mat;
import cezeri.transform.TransformFFT;
import cezeri.transform.TransformRadon;
import cezeri.utils.BruteForce;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.converters.ConverterUtils;
import weka.core.matrix.EigenvalueDecomposition;
import weka.core.matrix.Matrix;
import java.security.SecureRandom;
import cezeri.call_back_interface.CallBackWebSocket;
import cezeri.deep_learning.tensorflow_js.interfaces.InterfaceCallBack;
import cezeri.factory.FactoryDJL;
import cezeri.factory.FactoryDataBase;
import cezeri.types.TBlockType;
import cezeri.types.TDJLModel;
import cezeri.types.TRoi;
import com.google.gson.Gson;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.SQLException;
import static weka.core.Debug.DBO.p;

/**
 *
 * @author BAP1
 */
public final class CMatrix implements Serializable {

    public String name = "Matrix";
    private double[][] array;
    transient private BufferedImage image;
    private String imagePath;
    private CMatrix prevMatrix;
    private CMatrix nextMatrix;
    public CReturn returnedValue;
    private static long currentTime = System.nanoTime();
    private boolean hold_on = false;
    private Instances wekaInstance = null;
    public static FrameImage frameImage = null;
    private static FramePlot framePlot = null;
    private static FrameHeatMap frameHeatMap = null;
    public String plotType = "-";
    private List<String> columnNames = new ArrayList();
    private List classLabels = new ArrayList();
    private double[] xData4FX;
//    private static Random random = new SecureRandom();
    private Random random = new SecureRandom();
    private List classLabelValues = new ArrayList();
    private List classLabelNames = new ArrayList();
    public String[] combinationPairs;
    public String[] permutationPairs;
    public static CMatrix currentMatrix = null;
    private boolean isArraySet = false;
    private Translator<Image, Classifications> translator;
    private Predictor<Image, Classifications> predictor;
    private Model model;
    private String MODEL_NAME;
    private int NUM_CHANNEL;
    private int NUM_OUTPUT;
    private int IMAGE_WIDTH;
    private int IMAGE_HEIGHT;
    private int BLOCK_TYPE;
    private Block BLOCK;

    public CMatrix getCurrentMatrix() {
        return currentMatrix;
    }
    public int[] shuffleIndexes;

    public CMatrix buildFrameImage() {
        if (frameImage == null) {
            frameImage = new FrameImage();
            frameImage.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        return this;
    }

    public CMatrix buildFramePlot() {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        return this;
    }

    public Instances getWekaInstance() {
        return wekaInstance;
    }

    public CMatrix setWekaInstance(Instances wekaInstance) {
        this.wekaInstance = wekaInstance;
        this.wekaInstance.setClassIndex(this.wekaInstance.numAttributes() - 1);
        return CMatrix.fromInstances(this.wekaInstance);
    }

    public int getRowNumber() {
        return array.length;
    }

    public int getColumnNumber() {
        return array[0].length;
    }

    public BufferedImage getImage() {
        return image;
    }

    public CMatrix setImage(BufferedImage image) {
        this.image = image;
        this.array = ImageProcess.imageToPixelsDouble(GrayScale.luminosity(this.image));
        return this;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance() {
        CMatrix cm = new CMatrix();
        return cm;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance(ArrayList lst) {
        CMatrix cm = new CMatrix();
        cm = cm.fromArrayList(lst);
        return cm;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance(List lst) {
        CMatrix cm = new CMatrix();
        cm = cm.fromList(lst);
        return cm;
    }

    /**
     * calling conventions of static factory method pattern
     *
     * @return 1x1 CMatrix instance
     */
    public static CMatrix getInstance(CMatrix c) {
        CMatrix cm = c.clonePure();
        return cm;
    }

    /**
     * try to locate previous matrix if it exists
     *
     * @return previous Matrix
     */
    public CMatrix prev() {
        if (prevMatrix == null) {
            return this;
        }
        prevMatrix.nextMatrix = this;
        return prevMatrix;
    }

    /**
     * try to locate n previous matrix if it exists
     *
     * @param n
     * @return previous Matrix
     */
    public CMatrix prev(int n) {
        for (int i = 0; i < n - 1; i++) {
            prevMatrix = prevMatrix.prev();
        }
        return prevMatrix;
    }

    /**
     * try to locate first cezeri matrix
     *
     * @return previous Matrix
     */
    public CMatrix prevFirst() {
        while (prevMatrix.prevMatrix != null) {
            prevMatrix = prevMatrix.prev();
        }
        return prevMatrix;
    }

    /**
     * try to locate next matrix if it exists
     *
     * @return next Matrix
     */
    public CMatrix next() {
        if (nextMatrix == null) {
            return this;
        }
        nextMatrix.prevMatrix = this;
        return nextMatrix;
    }

    /**
     * try to locate n next matrix if it exists
     *
     * @return next Matrix
     */
    public CMatrix next(int n) {
        for (int i = 0; i < n - 1; i++) {
            nextMatrix = nextMatrix.next();
        }
        return nextMatrix;
    }

    /**
     * try to locate last cezeri matrix
     *
     * @return previous Matrix
     */
    public CMatrix nextLast() {
        while (nextMatrix.nextMatrix != null) {
            nextMatrix = nextMatrix.next();
        }
        return nextMatrix;
    }

    /**
     * generate nxn zero matrix
     *
     * @param n
     * @return CMatrix
     */
    public static CMatrix getInstance(int n) {
        return new CMatrix(n);
    }

    /**
     * generate mxn zero matrix
     *
     * @param m : number of rows
     * @param n : number of columns
     * @return CMatrix
     */
    public static CMatrix getInstance(int m, int n) {
        return new CMatrix(m, n);
    }

    /**
     * generate nr x nc with double value matrix
     *
     * @param nr : number of rows
     * @param nc : number of columns
     * @param value : double initial value
     * @return CMatrix
     */
    public static CMatrix getInstance(int nr, int nc, double value) {
        return new CMatrix(nr, nc).addScalar(value);
    }

    /**
     * generate matrix of img size, and values corresponding
     *
     * @param img : BufferedImage
     * @return CMatrix
     */
    public static CMatrix getInstance(BufferedImage img) {
        if (img == null) {
            return new CMatrix();
        }
        return new CMatrix(img);
    }

    /**
     * generate nxn zero matrix
     *
     * @param n:double (number of rows and columns)
     * @return CMatrix
     */
    public static CMatrix getInstance(double n) {
        return new CMatrix(n);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(int[] d) {
        return new CMatrix(d);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(long[] d) {
        return new CMatrix(d);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(byte[] d) {
        return new CMatrix(d);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(float[] d) {
        return new CMatrix(d);
    }

    /**
     * generate single row of matrix where number of colums equals to the length
     * of the array
     *
     * @param d: array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(double[] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: double array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(int[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: double array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(long[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: double array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(byte[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: double array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(float[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix that has d.length of rows and d[0].length of columns
     *
     * @param d: double array of int
     * @return CMatrix double type
     */
    public static CMatrix getInstance(double[][] d) {
        return new CMatrix(d);
    }

    /**
     * generate a matrix from open cv mat object
     *
     * @return CMatrix double type
     */
    public static CMatrix getInstance(Mat m) {
        double[][] d = ImageProcess.imageToPixels2DFromOpenCV(m);
        return new CMatrix(d);
    }

    /**
     * generate a matrix from the text file choosen, assuming item separator is
     * ;
     *
     * @return CMatrix double type
     */
    public static CMatrix getInstanceFromFile() {
        double[][] d = FactoryUtils.readFromFile();
        return new CMatrix(d);
    }

    /**
     * generate a matrix from the text file choosen, assuming item separator is
     * token
     *
     * @return CMatrix double type
     */
    public static CMatrix getInstanceFromFile(String token) {
        double[][] d = FactoryUtils.readFromFile(token);
        return new CMatrix(d);
    }

    /**
     * generate a matrix from the text file chosen, assuming item separator is
     * token
     *
     * @return CMatrix double type
     */
    public static CMatrix getInstanceFromFile(String fileName, String token) {
        double[][] d = FactoryUtils.readFromFile(fileName, token);
        return new CMatrix(d);
    }

    public static CMatrix getInstancesFromARFF(Instances m) {
        return fromInstances(m);
    }

    /**
     * generate a matrix from instances of Weka format
     *
     * @param m : Weka instances
     * @return CMatrix double type
     */
    public static CMatrix fromInstances(Instances m) {
        double[][] ret = new double[m.numInstances()][m.numAttributes()];
        for (int i = 0; i < m.numInstances(); i++) {
            Instance ins = m.instance(i);
            ret[i] = ins.toDoubleArray();
        }
        CMatrix cm = new CMatrix(ret);
        cm.wekaInstance = m;
        return cm;
    }

    /**
     * read Weka ARFF file format 2D data into CMatrix
     *
     * @param path : arff file path
     * @return
     */
    public static CMatrix getInstanceFromARFF(String path) {
        return fromARFF(path);
    }

    /**
     * read Excel sheet and transform data into CMatrix double[][] format
     *
     * @param path:excel file path
     * @return
     */
    public static CMatrix getInstanceFromExcelCSV(String path) {
        return new CMatrix(FactoryUtils.readCSV(path, ',', 0));
    }

    /**
     * read Excel sheet and transform data into CMatrix double[][] format
     *
     * @param path:excel file path
     * @return
     */
    public static CMatrix getInstanceFromExcelCSV(String path, char seperator, int headerline) {
        return new CMatrix(FactoryUtils.readCSV(path, seperator, headerline));
    }

    /**
     * generate a matrix from arff file format of Weka
     *
     * @param path : ARFF file path as String object
     * @return CMatrix double type
     */
    public static CMatrix fromARFF(String path) {
        try {
            Instances data = ConverterUtils.DataSource.read(path);
            data.setClassIndex(data.numAttributes() - 1);
            return CMatrix.fromInstances(data);
        } catch (Exception ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return CMatrix.getInstance();
    }

    /**
     * generate a matrix by reading arff file format of Weka
     *
     * @param path : ARFF file path as String object
     * @return CMatrix double type
     */
    public CMatrix readARFF(String path) {
        try {
            this.wekaInstance = ConverterUtils.DataSource.read(path);
            this.wekaInstance.setClassIndex(this.wekaInstance.numAttributes() - 1);
            return CMatrix.fromInstances(this.wekaInstance);
        } catch (Exception ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return CMatrix.getInstance();
    }

    /**
     * generate a matrix by reading csv file format and holds column names as
     * feature names and classLabels
     *
     * @param path : csv file path
     * @return CMatrix double type
     */
    public CMatrix readCSV(String path) {
        CMatrix ret = this.clone(this);

        ReaderCSV csv = FactoryUtils.readFromCSVFile(path);
        ret.array = csv.data;
        ret.columnNames = csv.columnNames;
        ret.classLabels = csv.classLabels;
        ret.image = ImageProcess.pixelsToImageGray(ret.array);

        return ret;
    }

    public String[][] readArffAsStringArray(String path) {
        try {
            this.wekaInstance = ConverterUtils.DataSource.read(path);
        } catch (Exception ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        this.wekaInstance.setClassIndex(this.wekaInstance.numAttributes() - 1);
        return FactoryUtils.readArffString(path, this.wekaInstance.numAttributes() - 1);
    }

    public String[][] readArffAsStringArray(String path, int classIndex) {
        return FactoryUtils.readArffString(path, classIndex);
    }

    /**
     * generate a matrix by loading the values read from image
     *
     * @param bf : BufferedImage
     * @return CMatrix
     */
    public CMatrix imload(BufferedImage bf) {
//        return new CMatrix(ImageProcess.imageToPixels255Int(GrayScale.luminosity(bf)));
        return new CMatrix(ImageProcess.imageToPixelsInt(bf));
    }

    /**
     * generate a matrix by loading the values read from image
     *
     * @param bf : BufferedImage
     * @return CMatrix
     */
    public CMatrix loadImage(BufferedImage bf) {
        return imload(bf);
    }

    /**
     * make a deep copy of the current matrix
     *
     * @return CMatrix
     */
    public CMatrix clonePure() {
        CMatrix ret = new CMatrix(FactoryMatrix.clone(this.array));
//        returnedValue.rgbImageArray = FactoryUtils.clone(this.rgbImageArray);
//        returnedValue.image = ImageProcess.clone(this.image);
        ret.image = ImageProcess.pixelsToImageGray(this.array);
        ret.name = this.name;
        ret.prevMatrix = this;
        ret.hold_on = this.hold_on;
        ret.framePlot = this.framePlot;
        return ret;
    }

    /**
     * make a deep copy of the given matrix
     *
     * @return CMatrix
     */
    public CMatrix clone(CMatrix cm) {
        CMatrix ret = new CMatrix(FactoryMatrix.clone(this.array));
//        returnedValue.rgbImageArray = FactoryUtils.clone(this.rgbImageArray);
//        if (this.image == null) {
//            returnedValue.image = ImageProcess.pixelsToBufferedImage255(this.array);
//        } else {
//            returnedValue.image = ImageProcess.clone(image);
//        }
        if (this.image != null) {
            ret.image = ImageProcess.clone(image);
            //ret.image = ImageProcess.pixelsToBufferedImage255(this.array);
        } else {
//            ret.image = ImageProcess.pixelsToImageGray(ret.array);
        }

        ret.name = this.name;
        ret.prevMatrix = cm;
        cm.nextMatrix = ret;
        ret.hold_on = cm.hold_on;
        ret.framePlot = cm.framePlot;
        ret.wekaInstance = this.wekaInstance;
        ret.columnNames = FactoryUtils.clone(this.columnNames);
        ret.classLabels = FactoryUtils.clone(this.classLabels);
        currentMatrix = ret;
        if (this.shuffleIndexes != null) {
            ret.shuffleIndexes = FactoryUtils.clone(this.shuffleIndexes);
        }
        ret.predictor = this.predictor;
        ret.translator = this.translator;
        ret.model = model;
        ret.NUM_CHANNEL = NUM_CHANNEL;
        ret.IMAGE_WIDTH = IMAGE_WIDTH;
        ret.IMAGE_HEIGHT = IMAGE_HEIGHT;
        ret.NUM_OUTPUT = NUM_OUTPUT;
        ret.BLOCK_TYPE = BLOCK_TYPE;
        ret.BLOCK = BLOCK;
        ret.MODEL_NAME = MODEL_NAME;
        return ret;
    }

    private CMatrix() {
        this.array = new double[1][1];
        this.returnedValue = new CReturn();
    }

    private CMatrix(int n) {
        n = Math.abs(n);
        this.array = new double[n][n];
        this.returnedValue = new CReturn();
    }

    private CMatrix(double m) {
        int n = (int) Math.abs(Math.round(m));
        this.array = new double[n][n];
        this.returnedValue = new CReturn();
    }

    private CMatrix(int r, int c) {
        r = Math.abs(r);
        c = Math.abs(c);
        this.array = new double[r][c];
        this.returnedValue = new CReturn();
    }

    private CMatrix(int[][] d) {
        this.array = FactoryUtils.toDoubleArray2D(FactoryMatrix.clone(d));
        this.returnedValue = new CReturn();
    }

    private CMatrix(byte[][] d) {
        this.array = FactoryUtils.toDoubleArray2D(FactoryMatrix.clone(d));
        this.returnedValue = new CReturn();
    }

    private CMatrix(double[][] d) {
        this.array = FactoryMatrix.clone(d);
        this.returnedValue = new CReturn();
    }

    private CMatrix(float[][] d) {
        this.array = FactoryUtils.toDoubleArray2D(FactoryMatrix.clone(d));
        this.returnedValue = new CReturn();
    }

    private CMatrix(double[] d) {
        double[][] m = new double[1][d.length];
        m[0] = d;
        this.array = FactoryUtils.transpose(m);
        this.returnedValue = new CReturn();
    }

    private CMatrix(Object[] d) {
        double[][] m = new double[1][d.length];
        for (int i = 0; i < d.length; i++) {
            m[0][i] = Double.parseDouble(d[i] + "");
        }
        this.array = FactoryUtils.transpose(m);
        this.returnedValue = new CReturn();
    }

    private CMatrix(float[] d) {
        float[][] m = new float[1][d.length];
        m[0] = d;
        this.array = FactoryUtils.toDoubleArray2D(FactoryUtils.transpose(m));
        this.returnedValue = new CReturn();
    }

    private CMatrix(int[] d) {
        double[][] m = new double[1][d.length];
        m[0] = FactoryUtils.toDoubleArray1D(d);
        this.array = FactoryUtils.transpose(m);
        this.returnedValue = new CReturn();
    }

    private CMatrix(long[] d) {
        double[][] m = new double[1][d.length];
        m[0] = FactoryUtils.toDoubleArray1D(d);
        this.array = FactoryUtils.transpose(m);
        this.returnedValue = new CReturn();
    }

    private CMatrix(byte[] d) {
        double[][] m = new double[1][d.length];
        m[0] = FactoryUtils.toDoubleArray1D(d);
        this.array = FactoryUtils.transpose(m);
        this.returnedValue = new CReturn();
    }

    private CMatrix(BufferedImage img) {
        this.image = img;
        this.array = ImageProcess.imageToPixelsDouble(img);
        this.returnedValue = new CReturn();
    }
//
//    public double[][] get2DArrayDouble() {
//        return array;
//    }
//
//    public double[][] toDouble() {
//        return array;
//    }
//
//    public float[][] toFloat() {
//        return FactoryUtils.toFloatArray(array);
//    }
//
//    public int[][] toInt() {
//        return FactoryUtils.toIntArray(array);
//    }
//
//    public byte[][] toByte() {
//        return FactoryUtils.toByteArray(array);
//    }
//
//    public short[][] toShort() {
//        return FactoryUtils.toShortArray(array);
//    }
//
//    public long[][] toLong() {
//        return FactoryUtils.toLongArray(array);
//    }

//    public String[][] toStringArray() {
//        return FactoryUtils.toStringArray(array);
//    }
    /**
     * get 1D double array which is identical to Matlab's a(:)
     *
     * @return double[]
     */
    public double[] toDoubleArray1D() {
        return FactoryUtils.toDoubleArray1D(this.array);
    }

    public double[][] toDoubleArray2D() {
        CMatrix cm = this;
//        if (image != null && image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
//            cm = toGrayLevel();
////            image = ImageProcess.rgb2gray(image);
////            array=ImageProcess.bufferedImageToArray2D(image);
//        }
        return cm.array;
    }

    /**
     * return Alpha, Red, Green and Blue values of original RGB image first
     * dimension contains spectral information second dimension is image height
     * (number of rows) third dimension is image width (number of columns)
     *
     * @return
     */
    public double[][][] toDoubleArray3D() {
        return ImageProcess.imageToPixelsColorDoubleFaster(image);
    }

    public int[] toIntArray1D() {
        return FactoryUtils.toIntArray1D(this.array);
    }

    public int[][] toIntArray2D() {
        return FactoryUtils.toIntArray2D(this.array);
    }

    public short[] toShortArray1D() {
        return FactoryUtils.toShortArray1D(this.array);
    }

    public short[][] toShortArray2D() {
        return FactoryUtils.toShortArray2D(this.array);
    }

    public float[] toFloatArray1D() {
        return FactoryUtils.toFloatArray1D(this.array);
    }

    public float[][] toFloatArray2D() {
        return FactoryUtils.toFloatArray2D(this.array);
    }

    public long[] toLongArray1D() {
        return FactoryUtils.toLongArray1D(this.array);
    }

    public long[][] toLongArray2D() {
        return FactoryUtils.toLongArray2D(this.array);
    }

    public String[] toStringArray1D() {
        return FactoryUtils.toStringArray1D(this.array);
    }

    public String[][] toStringArray2D() {
        return FactoryUtils.toStringArray2D(this.array);
    }

    public String[][] toStringArray2DAsInt() {
        return FactoryMatrix.toStringArray2DAsInt(this.array);
    }

    /**
     * set the array of current matrix note that clone is not calling so,
     * current matrix structure is changed
     *
     * @param a : double[]
     * @return CMatrix
     */
    public CMatrix setArray(double[] a) {
        double[][] d = new double[a.length][1];
        for (int i = 0; i < a.length; i++) {
            d[i][0] = a[i];
        }
        this.array = d;
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling so,
     * current matrix structure is changed
     *
     * @param a : double[]
     * @return CMatrix
     */
    public CMatrix setArray(double[] a, int r, int c) {
        double[][] d = new double[r][c];
        int k = 0;
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                d[i][j] = a[k++];
            }
        }
        this.array = d;
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling anymore,
     * current matrix structure will be changed
     *
     * @param a : int[]
     * @return CMatrix
     */
    public CMatrix setArray(int[] a) {
        if (a.length == 0) {
            return new CMatrix();
        }
        double[][] d = new double[a.length][1];
        for (int i = 0; i < a.length; i++) {
            d[i][0] = a[i];
        }
        this.array = d;
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling anymore,
     * current matrix structure will be changed
     *
     * @param a : int[][]
     * @return CMatrix
     */
    public CMatrix setArray(int[][] a) {
        if (a.length == 0) {
            return new CMatrix();
        }
        int r = a.length;
        int c = a[0].length;
        double[][] d = new double[r][c];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                d[i][j] = a[i][j];
            }
        }
        this.array = d;
        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling anymore,
     * current matrix structure will be changed
     *
     * @param array : double[][]
     * @return CMatrix
     */
    public CMatrix setArray(double[][] array) {
        this.array = array;
        double max = Math.max(Math.abs(this.getMaxTotal()), Math.abs(this.getMinTotal()));
        if (max <= 255) {
            this.image = ImageProcess.pixelsToImageGray(array);
        } else {
            this.image = ImageProcess.pixelsToImageColor(array);
            this.image = ImageProcess.convertToBufferedImageTypes(image, 5);
        }

        return this;
    }

    /**
     * set the array of current matrix note that clone is not calling anymore,
     * current matrix structure will be changed
     *
     * @param array : double[][][]
     * @return CMatrix
     */
    public CMatrix setArray(double[][][] array) {
        return fromARGB(array);
    }

    public CMatrix setValue(String p1, String p2, double val) {
        CMatrix ret = this.clone(this);
        double[][] d = FactoryMatrix.setValue(ret.array, p1, p2, val);
        ret.setArray(d);
        return ret;
    }

    /**
     * Try to update the value of the matrix which is specified by 1D index
     * array Note that this method can be used after calling the find method
     * which also produces the 1D column vector
     *
     *
     * @param indexes:results of find method or specific 1D index array that we
     * want to changed
     * @param val: value that we want to set it
     * @return updated CMatrix
     */
    public CMatrix setValue(int[] indexes, double val) {
        CMatrix ret = this.clone(this);

        double[] d = ret.toDoubleArray1D();
        for (int i = 0; i < indexes.length; i++) {
            d[indexes[i]] = val;
        }
        double[][] a = FactoryUtils.reshape(d, getRowNumber(), getColumnNumber());
        ret.setArray(a);
        return ret;
    }

    /**
     * change the value of the matrix at specified row and column
     *
     * @param cp
     * @param val
     * @return
     */
    public CMatrix setValue(CPoint cp, double val) {
        if (cp.row > this.getRowNumber() || cp.row < 0 || cp.column < 0 || cp.column > this.getColumnNumber()) {
            return this;
        }
        array[cp.row][cp.column] = val;
        return this;
    }

    /**
     * change the value of the matrix at specified row and column
     *
     * @param row
     * @param column
     * @param value
     * @return
     */
    public CMatrix setValue(int row, int column, double value) {
        if (row > this.getRowNumber() || row < 0 || column < 0 || column > this.getColumnNumber()) {
            return this;
        }
        array[row][column] = value;
        return this;
    }

    /**
     * Try to update the value of the matrix which is specified by 1D index
     * array Note that this method can be used after calling the find method
     * which also produces the 1D column vector
     *
     *
     * @param indexes:results of find method or specific 1D index array that we
     * want to changed
     * @param val: value that we want to set it
     * @return updated CMatrix
     */
    public CMatrix setValue(double[] indexes, double val) {
        CMatrix ret = this.clone(this);

        double[] d = ret.toDoubleArray1D();
        for (int i = 0; i < indexes.length; i++) {
            d[(int) indexes[i]] = val;
        }
        double[][] a = FactoryUtils.reshape(d, getRowNumber(), getColumnNumber());
        ret.setArray(a);
        return ret;
    }

    /**
     * column wised reshaping operation
     *
     * @param r
     * @param c
     * @return
     */
    public CMatrix reshape(int r, int c) {
        CMatrix ret = this.clone(this);

//        if (returnedValue.getColumnNumber() * returnedValue.getRowNumber() != r * c) {
//            FactoryUtils.showMessage("size mismatch please provide correct dimensions");
//            return returnedValue;
//        }        
        double[][] rs = FactoryUtils.reshape(ret.array, r, c);
        ret.setArray(rs);
        return ret;
    }

    public CMatrix setRowColumn(int i, int j, double p) {
        CMatrix ret = this.clone(this);

        ret.array[i][j] = p;
        return ret;
    }

    public CPoint getRowColumn(int index) {
        CPoint p = new CPoint(0, 0);
        if (index < 0 || index > this.getRowNumber() * this.getColumnNumber()) {
            return p;
        } else {
            int col = index / this.getRowNumber();
            int row = index - col * this.getRowNumber();
            p.column = col;
            p.row = row;
        }
        return p;
    }

    public CPoint getRowColumn(double index) {
        CPoint p = new CPoint(0, 0);
        if (index < 0 || index > this.getRowNumber() * this.getColumnNumber()) {
            return p;
        } else {
            int col = (int) index / this.getRowNumber();
            int row = (int) index - col * this.getRowNumber();
            p.column = col;
            p.row = row;
        }
        return p;
    }

    public CMatrix range2D(double from_inclusive, double to_exclusive) {
        CMatrix ret = new CMatrix();
        ret.setArray(FactoryMatrix.range2D(from_inclusive, to_exclusive, 1));
        return ret;
    }

    public CMatrix range2D(double from_inclusive, double to_exclusive, double step) {
        CMatrix ret = new CMatrix();
        ret.setArray(FactoryMatrix.range2D(from_inclusive, to_exclusive, step));
        return ret;
    }

    public CMatrix range(double from_inclusive, double to_exclusive) {
        return vector(from_inclusive, to_exclusive - 1);
    }

    public CMatrix range(int[] p) {
        CMatrix ret = CMatrix.getInstance(p);
        return ret;
    }

    public CMatrix range(double[] p) {
        CMatrix ret = CMatrix.getInstance(p);
        return ret;
    }

    public CMatrix range(String s) {
        if (!s.contains(":")) {
            System.out.println("should contain : range");
            return this;
        }
        double[] p = FactoryUtils.resolveParamForRange(s);
        CMatrix ret = CMatrix.getInstance(p);
        return ret;
    }

    public CMatrix range(int from_inclusive, int to_exclusive) {
        return vector(from_inclusive, to_exclusive);
    }

    public CMatrix range(int to_exclusive) {
        return vector(0, to_exclusive - 1);
    }

    public CMatrix range(double from_inclusive, double to_exclusive, double step) {
        return vector(from_inclusive, step, to_exclusive);
//        if (step > 0) {
//            return vector(from_inclusive, step, to_exclusive);
//        } else {
//            return vector(from_inclusive, step, to_exclusive);
//        }
    }

    public CMatrix rangeWithSampleNumber(double from_inclusive, double to_exclusive, int nSample) {
        return linspace(from_inclusive, to_exclusive - 1, nSample);
    }

    /**
     * executes as Matlab command of a=1:10;
     *
     * Matlab de a=1:10 denildiğinde nasıl ki 1 den 10 a kadar artan sayılardan
     * bir row matrisi yapar vector de bu işe yarar.
     *
     * @param from :double
     * @param to :double
     * @return CMatrix
     */
    public CMatrix vector(double from, double to) {
        CMatrix ret = this.clone(this);
        if (from < to) {
            return vector(from, 1, to);
        } else {
            return vector(from, -1, to);
        }
    }

    /**
     * matlab deki gibi başlangıçtan sona kadar incr artarak bir row matris
     * yapar
     *
     * @param from
     * @param incr
     * @param to
     * @return CMatrix
     */
    public CMatrix vector(double from, double incr, double to) {
        CMatrix ret = this.clone(this);
        if (from < to && incr < 0) {
            throw new UnsupportedOperationException("incr should be positive");
        }
        if (from > to && incr > 0) {
            throw new UnsupportedOperationException("incr should be negative");
        }
        double delta = Math.abs(to - from);
        int n = Math.abs((int) (delta / incr));
        ret.array = new double[1][n];
        for (int i = 0; i < n; i++) {
            ret.array[0][i] = from + i * incr;
        }
        ret.name = this.name + "|vector";
        return ret.transpose();
    }

    public CMatrix linspace(double from, double to, int n) {
        CMatrix ret = this.clone(this);
        if (n < 0) {
            throw new UnsupportedOperationException("n should be positive");
        }
        double delta = to - from;
        double incr = delta / n;
        ret.array = new double[1][n];
        for (int i = 0; i < n; i++) {
            ret.array[0][i] = from + i * incr;
        }
        ret.name = this.name + "|linspace";
        return ret.transpose();
    }

//    /**
//     * Matlab de a=1:10 denildiğinde nasıl ki 1 den 10 a kadar artan sayılardan
//     * bir row matrisi yapar vector de bu işe yarar.
//     *
//     * @param from
//     * @param to
//     * @return
//     */
//    public CMatrix vector(int from, int to) {
//        CMatrix ret = this.clone(this);
//        if (from > to) {
//            throw new UnsupportedOperationException("'from' should be smaller than 'to' other wise use another constructor");
//        }
//        int n = (int) (Math.abs(to - from) + 1);
//        ret.array = new double[1][n];
//        for (int i = 0; i < n; i++) {
//            ret.array[0][i] = from + i;
//        }
//        ret.name = this.name + "|vector";
//        return ret.transpose();
//    }
    public CMatrix vector2D(double from, double to, int nrows) {
        CMatrix ret = this.clone(this);

        if (from > to) {
            throw new UnsupportedOperationException("'from' should be smaller than 'to' other wise use another constructor");
        }
        int n = (int) (Math.abs(to - from) + 1);
        ret.array = new double[nrows][n];
        for (int i = 0; i < nrows; i++) {
            for (int j = 0; j < n; j++) {
                ret.array[i][j] = from + j;
            }
        }
        ret.name = this.name + "|vector2d";
        return ret;
    }

    public CMatrix vector2D(double from, double to, int nrows, int ncols) {
        CMatrix ret = this.clone(this);

        int n = ncols;
        double incr = (Math.abs(to - from) + 1.0) / ncols;
        ret.array = new double[nrows][n];
        double t = from;
        for (int i = 0; i < nrows; i++) {
            for (int j = 0; j < n; j++) {
                t += incr;
                ret.array[i][j] = t;
            }
            t = from;
        }
        ret.name = this.name + "|vector2d";
        return ret;
    }

    public CMatrix imgradient(int from, int to, int nrows) {
        CMatrix ret = this.clone(this);

        ret = vector2D(from, to, nrows);
        return ret;
    }

    public CMatrix imgradient(int from, int to, int nrows, int ncols) {
        CMatrix ret = this.clone(this);

        ret = vector2D(from, to, nrows, ncols);
        return ret;
    }

//    /**
//     * matlab deki gibi başlangıçtan sona kadar incr artarak bir row matris
//     * yapar
//     *
//     * @param from
//     * @param incr
//     * @param to
//     * @return
//     */
//    public CMatrix vector(int from, double incr, int to) {
//        CMatrix ret = this.clone(this);
//        if (from < to && incr < 0) {
//            throw new UnsupportedOperationException("incr should be positive");
//        }
//        if (from > to && incr > 0) {
//            throw new UnsupportedOperationException("incr should be negative");
//        }
//        double delta = Math.abs(to - from);
//        int n = Math.abs((int) (delta / incr));
//        ret.array = new double[1][n + 1];
//        for (int i = 0; i <= n; i++) {
//            ret.array[0][i] = from + i * incr;
//        }
//        ret.name = this.name + "|vector";
//        return ret.transpose();
//    }
//    public CMatrix linspace(int from, int to, int n) {
//        CMatrix ret = this.clone(this);
//        if (n < 0) {
//            throw new UnsupportedOperationException("n should be positive");
//        }
//        double delta = to - from;
//        double incr = delta / (n - 1);
//        ret.array = new double[1][n];
//        for (int i = 0; i < n; i++) {
//            ret.array[0][i] = from + i * incr;
//        }
//        ret.name = this.name + "|linspace";
//        return ret.transpose();
//    }
    /**
     * Build nxn identity matrix
     *
     * @param n
     * @return
     */
    public CMatrix eye(int n, double val) {
        CMatrix ret = new CMatrix(n);
        double[][] eye_array = FactoryMatrix.eye(n, val);
        ret.setArray(eye_array);
        ret.name = this.name + "|eye";
        return ret.clone(this);
    }

    /**
     * Build nxn identity matrix
     *
     * @param n
     * @return
     */
    public CMatrix eye(int n) {
        return eye(n, 1);
    }

    public CMatrix zeros(int n) {
        CMatrix ret = new CMatrix(n);
        ret.fillMatrix(0);
        ret.name = this.name + "|zeros";
        return ret.clone(this);
    }

    /**
     * generate a nr x nc-size matrix with a fixed value n
     *
     * @param nr
     * @param nc
     * @param n
     * @return
     */
    public CMatrix numbers(int nr, int nc, int n) {
        CMatrix ret = new CMatrix(nr, nc);
        ret.fillMatrix(n);
        ret.name = this.name + "|numbers";
        return ret.clone(this);
    }

    public CMatrix zeros(int r, int c) {
        CMatrix ret = new CMatrix(r, c);
        ret.fillMatrix(0);
        ret.name = this.name + "|zeros";
        return ret.clone(this);
    }

    public CMatrix ones(int n) {
        CMatrix ret = new CMatrix(n);
        ret.fillMatrix(1);
        ret.name = this.name + "|ones";
        return ret.clone(this);
    }

    public CMatrix ones(int r, int c) {
        CMatrix ret = new CMatrix(r, c);
        ret.fillMatrix(1);
        ret.name = this.name + "|ones";
        return ret.clone(this);
    }

    public CMatrix rand() {
        CMatrix ret = this.clone(this);
        ret.setArray(FactoryMatrix.fillRandMatrix(ret.array, random));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix randWithSeed(int seed) {
        CMatrix ret = this.clone(this);
        ret.setArray(FactoryMatrix.fillRandMatrixWithSeed(ret.array, seed));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix rand(int n) {
        CMatrix ret = new CMatrix(n);
        ret.setArray(FactoryMatrix.fillRandMatrix(ret.array, random));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix randWithSeed(int n, int seed) {
        CMatrix ret = new CMatrix(n);
        ret.setArray(FactoryMatrix.fillRandMatrixWithSeed(ret.array, seed));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix rand(int r, int c) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrix(ret.array, random));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix randWithSeed(int r, int c, int seed) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrixWithSeed(ret.array, seed));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix rand(int r, int c, Random rnd) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrix(ret.array, rnd));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix rand(int r, int c, int max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrix(ret.array, max, random));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix rand(int r, int c, double max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrix(ret.array, max, random));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix randWithSeed(int r, int c, double max, int seed) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrixWithSeed(ret.array, max, seed));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix rand(int r, int c, int min, int max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrix(ret.array, min, max, random));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    /**
     * randTimeSeries method generates random signal similar to the timeline
     * series of trends in any assets which provides us to inspect time series
     * signals in 1D
     *
     * @param r
     * @param c
     * @param min
     * @param max
     * @return
     */
    public CMatrix randTimeSeries(int r, int c, double min, double max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrixTimeSeries(ret.array, min, max, random));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix rand(int r, int c, double min, double max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrix(ret.array, min, max, random));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix randWithSeed(int r, int c, double min, double max, int seed) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandMatrixWithSeed(ret.array, min, max, seed));
        ret.name = this.name + "|rand";
        return ret.clone(this);
    }

    public CMatrix randn() {
        CMatrix ret = this.clone(this);
        ret.setArray(FactoryMatrix.fillRandNormalMatrix(ret.array, random));
        ret.name = this.name + "|randn";
        return ret.clone(this);
    }

    /**
     * Generates nxn square matrix with normal distribution
     *
     * @param n
     * @return
     */
    public CMatrix randn(int n) {
        CMatrix ret = new CMatrix(n);
        ret.setArray(FactoryMatrix.fillRandNormalMatrix(ret.array, random));
        ret.name = this.name + "|randn";
        return ret.clone(this);
    }

    /**
     * Generates rxc matrix with normal distribution
     *
     * @param r
     * @param c
     * @return
     */
    public CMatrix randn(int r, int c) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandNormalMatrix(ret.array, ret.random));
        ret.name = this.name + "|randn";
        return ret.clone(this);
    }

    /**
     * Generates rxc matrix with normal distribution within max upper bound
     *
     * @param r
     * @param c
     * @param max
     * @return
     */
    public CMatrix randn(int r, int c, int max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandNormalMatrix(ret.array, max, random));
        ret.name = this.name + "|randn";
        return ret.clone(this);
    }

    /**
     * Generates rxc matrix with normal distribution within max upper bound
     *
     * @param r
     * @param c
     * @param max
     * @return
     */
    public CMatrix randn(int r, int c, double max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandNormalMatrix(ret.array, max, random));
        ret.name = this.name + "|randn";
        return ret.clone(this);
    }

    /**
     * Generates rxc matrix with normal distribution within [min...max] bounds
     *
     * @param r
     * @param c
     * @param min
     * @param max
     * @return
     */
    public CMatrix randn(int r, int c, int min, int max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandNormalMatrix(ret.array, min, max, random));
        ret.name = this.name + "|randn";
        return ret.clone(this);
    }

    /**
     * Generates rxc matrix with normal distribution within [min...max] bounds
     *
     * @param r
     * @param c
     * @param min
     * @param max
     * @return
     */
    public CMatrix randn(int r, int c, double min, double max) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandNormalMatrix(ret.array, min, max, random));
        ret.name = this.name + "|randn";
        return ret.clone(this);
    }

    /**
     * With a given mean and variance generates rxc matrix with normal
     * distribution return variance*x+mean
     *
     * @param r
     * @param c
     * @param mean
     * @param var
     * @return
     */
    public CMatrix randnMeanVariance(int r, int c, double mean, double var) {
        CMatrix ret = new CMatrix(r, c);
        ret.setArray(FactoryMatrix.fillRandNormalMatrixMeanVar(ret.array, mean, var, random));
        ret.name = this.name + "|randn";
        return ret.clone(this);
    }

    /**
     * Plot scatter graph of the first two column vectors of the CMatrix Another
     * usage is an overloaded scatter method which takes two vector as an input
     * parameter or two CMatrix objects.
     *
     *
     *
     * @return CMatrix
     */
    public CMatrix scatter() {
        FrameScatterPlot frm = new FrameScatterPlot(this);
        frm.setVisible(true);
        return this;
    }

    /**
     * Plot scatter graph of two vector (double[] array) as an input parameter.
     *
     * Notification: two vectors should be the same size
     *
     * @return CMatrix
     */
    public CMatrix scatter(double[] x, double[] y) {
        if (x.length != y.length) {
            System.err.println("Array dimension mismatched.");
        }
        int n = Math.min(x.length, y.length);
        double[][] d = FactoryMatrix.catHorizontalMatrix(x, y);
        FrameScatterPlot frm = new FrameScatterPlot(CMatrix.getInstance(d));
        frm.setVisible(true);
        return this;
    }

    /**
     * used as Matlab scatter function with figure attribute values
     *
     * @param attr : figure attribute values
     * @return CMatrix
     */
    public CMatrix scatter(TFigureAttribute attr) {
        FrameScatterPlot frm = new FrameScatterPlot(this, attr);
        frm.setVisible(true);
        return this;
    }

    /**
     * Matlab compatible command: plot the curves of each column in the matrix
     *
     * @return CMatrix
     */
    public CMatrix plot() {
        if (!hold_on) {
            framePlot = new FramePlot(this);
        } else {
            if (framePlot == null) {
                framePlot = new FramePlot(this);
            }
            framePlot.setMatrix(this);
        }
        TFigureAttribute fg = new TFigureAttribute();
        fg.pointType = plotType;
        framePlot.setFigureAttribute(fg);
        framePlot.setVisible(true);
        return this;
    }

    /**
     * plot the curves of each column in the matrix
     *
     * @return CMatrix
     */
    public CMatrix plotRefresh(FramePlot frm) {
        frm.setMatrix(this);
        frm.setVisible(true);
        return this;
    }

    /**
     * By using single plot frame, this command try to redraw updated matrix it
     * is useful if you make animation or moving simulation within the loop
     *
     * @return CMatrix
     */
    public CMatrix plotRefresh() {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setVisible(true);
        return this;
    }

    /**
     * By using single plot frame, this command try to redraw updated matrix it
     * is useful if you make animation or moving simulation within the loop
     *
     * @return CMatrix
     */
    public CMatrix plotRefresh(TFigureAttribute fg) {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setFigureAttribute(fg);
        framePlot.setVisible(true);
        return this;
    }

    public CMatrix plotRefresh(TFigureAttribute fg, String caption) {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setFigureAttribute(fg);
        framePlot.setVisible(true);
        framePlot.setTitle(caption);
        return this;
    }

    /**
     * By using single plot frame, this command try to redraw updated matrix it
     * is useful if you make animation or moving simulation within the loop
     *
     * @return CMatrix
     */
    public CMatrix plotRefresh(double[] x) {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setVisible(true);
        return this;
    }

    /**
     * By using single plot frame, this command try to redraw updated matrix it
     * is useful if you make animation or moving simulation within the loop
     *
     * @return CMatrix
     */
    public CMatrix plotOn() {
        if (framePlot == null) {
            framePlot = new FramePlot(this);
            framePlot.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        framePlot.setMatrix(this);
        framePlot.setVisible(true);
        return this;
    }

    /**
     * plot the curves of each column in the matrix
     *
     * @return CMatrix
     */
    public CMatrix bar() {
        FrameBar frm = new FrameBar(this);
        frm.setVisible(true);
        return this;
    }

    /**
     * plot the curves based on provided x axis values
     *
     * @param x:value of x axis
     * @return
     */
    public CMatrix plot(double[] x) {
        FramePlot frm = new FramePlot(this, x);
        frm.setVisible(true);
        return this;
    }

    public CMatrix plot(TFigureAttribute attr) {
        FramePlot frm = new FramePlot(this, attr);
        frm.setVisible(true);
        return this;
    }

    public CMatrix plot(TFigureAttribute attr, double[] x) {
        FramePlot frm = new FramePlot(this, attr, x);
        frm.setVisible(true);
        return this;
    }

    public CMatrix setPlotType(String pointType) {
        this.plotType = pointType;
        return this;
    }

    public CMatrix plot(String title) {
        FramePlot frm = new FramePlot(this);
        frm.setPlotType(this.plotType);
        frm.setVisible(true);
        frm.setTitle(title);
        return this;
    }

    /**
     * Matlab compatible command: show image in the frame
     *
     *
     * Matlabdakine benzer şekilde temel resim gösteren figure açar default
     * olarak imgenin orjinali nasılsa onu gösterir gri ise gri rgb ise rgb
     * değişiklik yapmaz. Eğer gri göstrmek istiyorsanız imshowGray komutunu,
     * diğer taraftan renkli göstermek için de imshowRGB yi kullanınız.
     *
     * @return
     */
    public CMatrix imshow() {
        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array);
        }
//        if (image == null) {
//            image = ImageProcess.pixelsToImageGray(array);
//        }
        //image = ImageProcess.pixelsToImageGray(array);
        FrameImage frm = new FrameImage(this, this.imagePath);
        frm.setVisible(true);
        return this;
    }

    /**
     * Matlab compatible command: show image in the frame
     *
     *
     * Matlabdakine benzer şekilde temel resim gösteren figure açar default
     * olarak imgenin orjinali nasılsa onu gösterir gri ise gri rgb ise rgb
     * değişiklik yapmaz. Eğer gri göstrmek istiyorsanız imshowGray komutunu,
     * diğer taraftan renkli göstermek için de imshowRGB yi kullanınız.
     *
     * @return
     */
    public CMatrix imshow(boolean isUpdate) {
        if (image == null || isUpdate) {
            image = ImageProcess.pixelsToImageGray(array);
        }
        FrameImage frm = new FrameImage(this, this.imagePath);
        frm.setVisible(true);
        return this;
    }

    /**
     *
     * show on single frame for each call only one frame is maintained
     *
     * @param title:caption of the frame
     * @return
     */
    public CMatrix imshowRefresh(String title) {
        if (image == null) {
            if (FactoryUtils.getMaximum(array) > 0.0) {
                image = ImageProcess.pixelsToImageGray(array);
            } else {
                image = ImageProcess.pixelsToImageColor(array);
            }
        }
        if (image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array);
        } else if (image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageColor(array);
        }
        if (frameImage == null) {
            frameImage = new FrameImage();
            frameImage.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }
        frameImage.setImage(image);
        frameImage.setTitle(title);
        frameImage.setVisible(true);
        return this;
    }

    /**
     *
     * show on single frame for each call only one frame is maintained
     *
     * @return
     */
    public CMatrix imshowRefresh() {
        return imshowRefresh("");
    }

    /**
     *
     * show on single frame for each call only one frame is maintained
     *
     * @return
     */
    public CMatrix imRefresh() {
        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array);
        }
        return this;
    }

    /**
     * Traditional imshow reopens a new Figure foreach call. If we want to
     * utilize single Frame we should pass object as a parameter to the
     * overloaded imshow method
     *
     * @param frm
     * @return
     */
    public CMatrix imshow(FrameImage frm) {
//        image = ImageProcess.pixelsToBufferedImageGray(array);
        frm.setImage(image);
        frm.setVisible(true);
        return this;
    }

//    /**
//     * Traditional imshow reopens a new Figure foreach call. If we want to
//     * utilize single Frame we should pass object as a parameter to the
//     * overloaded imshow method
//     *
//     * @param frm
//     * @return
//     */
//    public CMatrix imshow(FrameImage frm, boolean force) {
//        if (force) {
//            
//        }
//        image = ImageProcess.pixelsToBufferedImage255(array);
//        frm.setImage(image);
//        frm.setVisible(true);
//        return this;
//    }
    /**
     * Traditional imshow reopens a new Figure foreach call. If we want to
     * utilize single Frame we should pass object as a parameter to the
     * overloaded imshow method
     *
     * @param frm
     * @return
     */
    public CMatrix imshow(FrameImage frm, String title) {
        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array);
        }
        frm.setImage(image);
        frm.setVisible(true);
        return this;
    }

    /**
     * opens a figure and show the image on that figure refresh tries to build
     * image from the matrix
     *
     * @return
     */
//    public CMatrix imshow(boolean refresh) {
//        imshowRGB(refresh);
//        return this;
//    }
    /**
     * opens the figure with image
     *
     * @param title: caption of the figure
     * @return
     */
    public CMatrix imshow(String title) {
//        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
//            image = ImageProcess.pixelsToImageGray(array);
//        }
        if (image == null) {
            image = ImageProcess.pixelsToImageGray(array);
        }
        FrameImage frm = new FrameImage(this, title);
        frm.setVisible(true);
        return this;
    }

    /**
     * Detaylı ve gelişmiş resim gösteren figure açar
     *
     * @return
     */
//    public CMatrix imshowAdvanced() {
//        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
//            image = ImageProcess.pixelsToBufferedImage255(array);
//        }
//        FrameImageAdvanced frm = new FrameImageAdvanced(image, imagePath);
//        frm.setVisible(true);
//        return this;
//    }
    /**
     * Detaylı ve gelişmiş resim gösteren figure açar
     *
     * @return
     */
//    public CMatrix imshowAdvanced(String title) {
//        if (image == null || image.getType() == BufferedImage.TYPE_BYTE<_GRAY) {
//            image = ImageProcess.pixelsToBufferedImage255(array);
//        }
//        FrameImageAdvanced frm = new FrameImageAdvanced(image, title);
//        frm.setVisible(true);
//        return this;
//    }
//    public CMatrix imshowGray() {
////        if (image == null) {
////            image = ImageProcess.pixelsToBufferedImage255(FactoryUtils.toIntArray(array));
////        }
//        image = ImageProcess.pixelsToBufferedImage255(array);
////        FrameImage frm = new FrameImage(ImageProcess.pixelsToBufferedImage255(ImageProcess.imageToPixels255(image)), this.imagePath);
//        FrameImage frm = new FrameImage(image, this.imagePath);
//        frm.setVisible(true);
//        return this;
//    }
    public CMatrix toGrayLevel() {
        CMatrix ret = this.clone(this);
        if (ret.image != null) {
            ret.image = ImageProcess.toGrayLevel(ret.image);
            ret.array = ImageProcess.bufferedImageToArray2D(ret.image);
        } else {
            ret.array = ImageProcess.bufferedImageToArray2D(ret.image);
            ret.image = ImageProcess.pixelsToImageGray(ret.array);
        }
        return ret;
    }

    /**
     * convert RGB color image to the Gray Value. This method is MATLAB
     * compatible
     *
     * @return
     */
    public CMatrix rgb2gray() {
        return toGrayLevel();
    }

    /**
     * convert RGB color image to the Hue Saturation and Value (Note that Value
     * is sometimes called as Brightness value therefore naming HSV as HSB is
     * also correct convention) this methos is MATLAB compatible
     *
     * @return
     */
    public CMatrix rgb2hsv() {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.rgb2hsv(ret.image);
        return ret;
    }

    public CMatrix hsv2rgb() {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.hsv2rgb(ret.image);
        return ret;
    }

//    public CMatrix toHSV() {
//        CMatrix ret = this.clone(this); lastCM=ret; 
//        ret.image = ImageProcess.toHSVColorSpace(ret.image);
//        return ret;
//    }
    public CMatrix getHueChannel() {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.getHueChannel(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix getSaturationChannel() {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.getSaturationChannel(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix getValueChannel() {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.getValueChannel(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    /**
     * Matlabdakine benzer şekilde temel resim gösteren figure açar
     *
     * @return
     */
    public CMatrix showImage() {
        return CMatrix.this.imshow();
    }

    /**
     * Matlabdakine benzer şekilde temel resim gösteren figure açar
     *
     * @return
     */
    public CMatrix showImage(String title) {
        return CMatrix.this.imshow(title);
    }

    /**
     * Detaylı ve gelişmiş resim gösteren figure açar
     *
     * @return
     */
//    public CMatrix showImageAdvanced() {
//        return imshowAdvanced();
//    }
    /**
     * Detaylı ve gelişmiş resim gösteren figure açar
     *
     * @param title:caption of the figure
     * @return
     */
//    public CMatrix showImageAdvanced(String title) {
//        return imshowAdvanced(title);
//    }
//    public CMatrix imshowRGB() {
//        image = ImageProcess.pixelsToBufferedImage255(FactoryUtils.toIntArray(array));
//        FrameImage frm = new FrameImage(image, this.imagePath);
//        frm.setVisible(true);
//        return this;
//    }
//    public CMatrix imshowRGB(boolean refresh) {
//        if (image == null || refresh) {
//            image = ImageProcess.pixelsToBufferedImage255(FactoryUtils.toIntArray(array));
//        }
//        FrameImage frm = new FrameImage(image, this.imagePath);
//        frm.setVisible(true);
//        return this;
//    }
//    public CMatrix showRGBImage() {
//        return imshowRGB();
//    }
    /**
     * Matlab compatible command: show image histogram
     *
     * is used for only images for matrix you should use hist instead
     *
     * @return original CMatrix
     */
    public CMatrix imhist() {
        return imhist("");
    }

    public CMatrix imhist(String title) {
        CMatrix ret = this.clone(this);

        if (ret.image == null || ret.image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            ret.image = ImageProcess.pixelsToImageGray(array);
        }
        CMatrix cc = ImageProcess.getHistogram(ret);
        FrameImageHistogram frm = new FrameImageHistogram(cc);
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    /**
     * is used for revert or invert the image color
     *
     * @return
     */
    public CMatrix imcomplement() {
        CMatrix ret = this.clone(this);

        ret = ret.rgb2gray();
        BufferedImage bf = ImageProcess.revert(ret.image);
        ret.setImage(bf);
        return ret;
    }

    /**
     * is used for revert or invert the image color
     *
     * @return
     */
    public CMatrix imnegative() {
        return imcomplement();
    }

    /**
     * hist by default calculates 256 bin for a given column matrix
     *
     * @return histogram of each column
     */
    public CMatrix hist() {
        CMatrix ret = this.clone(this);

        ret.array = FactoryUtils.hist(ret.array);
        ret.bar();
        return this;
    }

    /**
     * Matlab compatible code: calculate the histogram of the matrix for a
     * specified number of bins as column wised
     *
     * @return histogram of each column
     */
    public CMatrix hist(int nBins) {
        CMatrix ret = this.clone(this);

        if (ret.getRowNumber() == 1 && ret.getColumnNumber() == 1) {
            return ret;
        } else if (ret.getRowNumber() == 1 && ret.getColumnNumber() > 1) {
            ret = ret.transpose();
        }
        ret.array = FactoryUtils.hist(ret.array, nBins);
        FrameHistogram frm = new FrameHistogram(this.clone(this), ret);
        frm.setVisible(true);
        return ret;
    }

    /**
     * calculate the histogram of the matrix for a specified number of bins as
     * column wised
     *
     * @return histogram of each column
     */
    public CMatrix hist(int nBins, String title) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryUtils.hist(ret.array, nBins);
        FrameHistogram frm = new FrameHistogram(this.clone(this), ret, title);
        frm.setVisible(true);
        return this;
    }

    /**
     * calculate the histogram of the matrix for a specified number of bins as
     * column wised
     *
     * @return histogram of each column
     */
    public CMatrix hist(int nBins, String title, boolean isStatisticsVisible) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryUtils.hist(ret.array, nBins);
        FrameHistogram frm = new FrameHistogram(this.clone(this), ret, title, isStatisticsVisible);
        frm.setVisible(true);
        return this;
    }

    public CMatrix getImageHistogramData() {
        CMatrix ret = this.clone(this);

        return ImageProcess.getHistogram(ret);
    }

    public CMatrix getHistogramData() {
        CMatrix ret = this.clone(this);

        ret.array = FactoryUtils.hist(ret.array);
        return ret;
    }

    public CMatrix getHistogramData(int nBins) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryUtils.hist(ret.array, nBins);
        return ret;
    }

    public CMatrix showHistogram() {
        return imhist();
    }

    /**
     * Probability Density Function (image histogram normalize to 0..1)
     *
     * @return
     */
    public CMatrix pdf() {
        return getPDFData();
    }

    /**
     * Cumulative Density Function
     *
     * @return
     */
    public CMatrix cdf() {
        return getCDFData();
    }

    public CMatrix getPDFData() {
        CMatrix ret = this.clone(this);

        ret = ret.toGrayLevel();
        CMatrix m_hist = ImageProcess.getHistogram(ret);
        double sum = m_hist.sumTotal();
        m_hist = m_hist.divideScalar(sum).clone(m_hist);
        return m_hist.transpose();
    }

    public CMatrix getCDFData() {
        double[] h_pdf = getPDFData().toDoubleArray1D();
        double[] h_cdf = new double[h_pdf.length];
        double t = 0;
        for (int i = 0; i < h_pdf.length; i++) {
            t += h_pdf[i];
            h_cdf[i] = t;
        }
        CMatrix ret = this.clone(this);

        ret.setArray(h_cdf);
        return ret;
//        CMatrix ret = this.clone(this); lastCM=ret; 
//        CMatrix m_hist = ImageProcess.getHistogram(ret);
//        double sum = m_hist.sumTotal();
//        m_hist = m_hist.divideScalar(sum).clone(m_hist);
//        double[] d = m_hist.toDoubleArray1D();
//        double[] r = new double[d.length];
//        for (int i = 0; i < d.length; i++) {
//            r[i] = FactoryUtils.sum(d, i);
//        }
//        m_hist.setArray(r);
//        return m_hist.transpose();
    }

    public CMatrix showPDF() {
        this.pdf().plot();
        return this;
    }

    public CMatrix showCDF() {
        this.cdf().plot();
        return this;
    }

    public CMatrix imhistRed() {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramRed(this));
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistGreen() {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramGreen(this));
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistBlue() {
        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramBlue(this));
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistGray() {
        return imhist();
    }

    public CMatrix imhistRed(String title) {
        CMatrix ret = this.clone(this);

        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramRed(ret));
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistGreen(String title) {
        CMatrix ret = this.clone(this);

        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramGreen(ret));
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistBlue(String title) {
        CMatrix ret = this.clone(this);

        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramBlue(ret));
        frm.setTitle(title);
        frm.setVisible(true);
        return this;
    }

    public CMatrix imhistGray(String title) {
        return imhist(title);
    }

    public CMatrix imhistAlpha() {
        CMatrix ret = this.clone(this);

        FrameImageHistogram frm = new FrameImageHistogram(ImageProcess.getHistogramAlpha(ret));
        frm.setVisible(true);
        return this;
    }

    public CMatrix showHistogramRed() {
        return imhistRed();
    }

    public CMatrix showHistogramGreen() {
        return imhistGreen();
    }

    public CMatrix showHistogramBlue() {
        return imhistBlue();
    }

    public CMatrix showHistogramGray() {
        return imhistGray();
    }

    public CMatrix showHistogramAlpha() {
        return imhistAlpha();
    }

    public CMatrix showDataGrid() {
        CMatrix ret = this;
        FrameDataGrid frm = new FrameDataGrid(ret);
        frm.setVisible(true);
        return this;
    }

    public CMatrix formatDouble(int n) {
        CMatrix ret = this.clone(this);

        double[][] r = new double[this.getRowNumber()][this.getColumnNumber()];
        for (int i = 0; i < this.getRowNumber(); i++) {
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r[i][j] = FactoryUtils.formatDouble(ret.array[i][j], n);
            }
        }
        ret.setArray(r);
        ret.name = this.name + "|formatDouble";
        return ret;
    }

    public void fillMatrix(double n) {
        for (int i = 0; i < this.array.length; i++) {
            for (int j = 0; j < this.array[0].length; j++) {
                this.array[i][j] = n;
            }
        }
    }

    public CMatrix merge(CMatrix m2, String type) {
        CMatrix m1 = this.clone(this);
        CMatrix ret = null;

        //alt alta eklemek için ";" kullanılır
        if (type.equals(";")) {
            ret = CMatrix.this.zeros(m1.getRowNumber() + m2.getRowNumber(), m1.getColumnNumber());
            for (int i = 0; i < m1.getRowNumber(); i++) {
                ret.array[i] = m1.array[i];
            }
            for (int i = m1.getRowNumber(); i < m1.getRowNumber() + m2.getRowNumber(); i++) {
                ret.array[i] = m2.array[i - m1.getRowNumber()];
            }
        }
        //yan yana eklemek için "," kullanılır
        if (type.equals(",")) {
            ret = CMatrix.this.zeros(m1.getRowNumber(), m1.getColumnNumber() + m2.getColumnNumber());
            ret = ret.transpose();
            m1 = m1.transpose();
            m2 = m2.transpose();
            for (int i = 0; i < m1.getRowNumber(); i++) {
                ret.array[i] = m1.array[i];
            }
            for (int i = m1.getRowNumber(); i < m1.getRowNumber() + m2.getRowNumber(); i++) {
                ret.array[i] = m2.array[i - m1.getRowNumber()];
            }
            ret = ret.transpose();
//            returnedValue = merge(m2.transpose(), ";");
//            returnedValue = returnedValue.transpose();
        }
        ret.name = this.name + "|merge";

        return ret;
    }

    public CMatrix transpose() {
        CMatrix ret = CMatrix.this.zeros(getColumnNumber(), getRowNumber());
        ret.name = this.name + "|transpose";
        for (int i = 0; i < getColumnNumber(); i++) {
            for (int j = 0; j < getRowNumber(); j++) {
                ret.array[i][j] = array[j][i];
            }
        }
//        returnedValue.rgbImageArray = FactoryUtils.clone(rgbImageArray);
        ret.image = this.image;
        ret.name = this.name + "|transpose";
        return ret;
    }

//    public int[][] to2DArrayInteger() {
//        int[][] ret = new int[getRowNumber()][getColumnNumber()];
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[i][j] = (int) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public double[][] to2DArrayDouble() {
//        return this.array;
//    }
//
//    /**
//     * this functions try to change the current matrix structure to 1D as
//     * Matlab's a(:) convention
//     *
//     * @return
//     */
//    public double[] to1DArrayDouble() {
//        double[] ret = FactoryUtils.to1D(this.array);
//        this.setArray(ret);
//        return ret;
//    }
//    public double[][][] to3DArrayDouble() {
//        return rgbImageArray;
//    }
//
//    public double[][][] get3DArrayDouble() {
//        return rgbImageArray;
//    }
//    public int[] to1DArrayInteger() {
//        int[] ret = new int[getRowNumber() * getColumnNumber()];
//        int k = 0;
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[k++] = (int) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public byte[][] to2DArrayByte() {
//        byte[][] ret = new byte[getRowNumber()][getColumnNumber()];
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[i][j] = (byte) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public short[][] to2DArrayShort() {
//        short[][] ret = new short[getRowNumber()][getColumnNumber()];
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[i][j] = (short) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public byte[] to1DArrayByte() {
//        byte[] ret = new byte[getRowNumber() * getColumnNumber()];
//        int k = 0;
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[k++] = (byte) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public short[] to1DArrayShort() {
//        short[] ret = new short[getRowNumber() * getColumnNumber()];
//        int k = 0;
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[k++] = (short) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public long[][] to2DArrayLong() {
//        long[][] ret = new long[getRowNumber()][getColumnNumber()];
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[i][j] = (long) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public long[] to1DArrayLong() {
//        long[] ret = new long[getRowNumber() * getColumnNumber()];
//        int k = 0;
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[k++] = (long) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public float[][] to2DArrayFloat() {
//        float[][] ret = new float[getRowNumber()][getColumnNumber()];
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[i][j] = (float) array[i][j];
//            }
//        }
//        return ret;
//    }
//
//    public float[] to1DArrayFloat() {
//        float[] ret = new float[getRowNumber() * getColumnNumber()];
//        int k = 0;
//        for (int i = 0; i < getRowNumber(); i++) {
//            for (int j = 0; j < getColumnNumber(); j++) {
//                ret[k++] = (float) array[i][j];
//            }
//        }
//        return ret;
//    }
    public CMatrix subMatrix(CMatrix m, Point p1, Point p2) {
        int r = m.array.length;
        int c = m.array[0].length;
        CMatrix ret = m;
        if (p1.x < 0 || p1.y < 0 || p1.x > p2.x || p1.y > p2.y || p1.x > r || p1.y > c || p2.x > r || p2.y > c) {
            return null;
        } else {
            double[][] d = new double[p2.x - p1.x][p2.y - p1.y];
            for (int i = p1.x; i < p2.x; i++) {
                for (int j = p1.y; j < p2.y; j++) {
                    d[i - p1.x][j - p1.y] = m.array[i][j];
                }
            }
            ret.setArray(d);
            ret.name = this.name + "|submatrix";
            return ret;
        }
    }

    public CMatrix subMatrix(Point p1, Point p2) {
        CMatrix ret = this.clone(this);

        int r = ret.array[0].length;
        int c = ret.array.length;
        if (p1.x < 0 || p1.y < 0 || p1.x > p2.x || p1.y > p2.y || p1.x > r || p1.y > c || p2.x > r || p2.y > c) {
            return null;
        } else {
            double[][] d = new double[p2.y - p1.y][p2.x - p1.x];
            for (int i = p1.x; i < p2.x; i++) {
                for (int j = p1.y; j < p2.y; j++) {
                    d[j - p1.y][i - p1.x] = ret.array[j][i];
                }
            }
            ret.setArray(d);
            ret.name = this.name + "|submatrix";
            return ret;
        }
    }

    public CMatrix subMatrix(CPoint p1, CPoint p2) {
        CMatrix ret = this.clone(this);

        int r = ret.array[0].length;
        int c = ret.array.length;
        if (p1.column < 0 || p1.row < 0 || p1.column > p2.column || p1.row > p2.row || p1.column > r || p1.row > c || p2.column > r || p2.row > c) {
            return null;
        } else {
            double[][] d = new double[p2.row - p1.row][p2.column - p1.column];
            for (int i = p1.column; i < p2.column; i++) {
                for (int j = p1.row; j < p2.row; j++) {
                    d[j - p1.row][i - p1.column] = ret.array[j][i];
                }
            }
            ret.setArray(d);
            ret.name = this.name + "|submatrix";
            return ret;
        }
    }

    public CMatrix subMatrix(Rectangle rect) {
        Point p1 = new Point(rect.x, rect.y);
        Point p2 = new Point(rect.x + rect.width, rect.y + rect.height);
        return subMatrix(p1, p2);
    }

    /**
     * Biiznillah Matlab de herhangi bir matrisin içeriğini mesela
     * a=b([1,4,11]); şeklinde alabiliyorduk burada aynı işlem yapılmaya
     * çalışılmıştır. 1 parametre girilse row lardan ilgili index teki verileri
     * filtreler 2 paramatre girilirse hem row hem column filtresi yapar.
     *
     * dynamic parameter
     *
     * @param p
     * @return
     */
    public CMatrix matrix(int[] p) {
        double[] ret = new double[1];
        if (p.length == 0) {
            return null;
        } else if (p.length > 0) {
            int[] rows = p;
            ret = new double[rows.length];
            double[] one_d = this.toDoubleArray1D();
            for (int i = 0; i < rows.length; i++) {
                try {
                    ret[i] = one_d[rows[i]];
                } catch (Exception e) {
                    e.printStackTrace();
                }

            }
        } else {
//            int[] rows = p[0];
//            int[] cols = p[1];
//            d = new double[rows.length][this.getColumnNumber()];
//            for (int i = 0; i < rows.length; i++) {
//                d[i] = this.array[rows[i]];
//            }
//            d = new CMatrix(d).transpose().array;
//            double[][] d2 = new double[cols.length][d[0].length];
//            for (int i = 0; i < cols.length; i++) {
//                d2[i] = d[cols[i]];
//            }
//            d = new CMatrix(d2).transpose().array;
        }
        CMatrix ret_matrix = new CMatrix(ret);
        ret_matrix.name = this.name + "|submatrix";
        return ret_matrix;
    }

    public CMatrix row(CMatrix prev, int[] rows) {
        double[][] d;
        d = new double[rows.length][this.getColumnNumber()];
        for (int i = 0; i < rows.length; i++) {
            d[i] = this.array[rows[i]];
        }
        CMatrix ret = this.clone(this);

        ret.array = d;
        ret.name = this.name + "|row";
        ret.prevMatrix = prev;
        return ret;
    }

    public CMatrix column(CMatrix prev, int[] cols) {
        double[][] yedek = new CMatrix(prev.array).transpose().array;
        double[][] d = new double[cols.length][yedek[0].length];
        for (int i = 0; i < cols.length; i++) {
            d[i] = yedek[cols[i]];
        }
        d = new CMatrix(d).transpose().array;
        CMatrix ret = new CMatrix(d);
        ret.name = this.name + "|column";
        ret.prevMatrix = prev;
        return ret;
    }

    /**
     * converts 2D Matrix to 1D matrix by executing : command
     *
     * @return CMatrix
     */
    public CMatrix matrix(String p) {
        CMatrix ret = this.clone(this);

        if (p.equals(":")) {
            ret = new CMatrix(ret.toDoubleArray1D());
        }
        ret.image = null;
        return ret;
    }

    /**
     * Tries to interpret String parameter as Matlab vectorization commands like
     * that interpret([1,3,5],[3,7]) means get subset based on the specified
     * criteria
     *
     * @param p
     * @return
     */
    public CMatrix cmd(int[] p) {
        return matrix(p);
    }

    /**
     * Tries to interpret String parameter as Matlab vectorization commands like
     * that interpret(":") means get subset based on the specified criteria
     *
     * @param p
     * @return
     */
    public CMatrix cmd(String p) {
        return matrix(p);
    }

    /**
     * Tries to interpret String parameter as Matlab or Python slicing
     * operations for example cmd("1:3,5:-1","-3:")
     *
     * @param p1 :
     * @param p2 :
     * @return
     */
    public CMatrix cmd(String p1, String p2) {
        CMatrix ret = this.clone(this);
        ret.setArray(FactoryMatrix.cmd(this.array, p1, p2));
        return ret;
    }

    /**
     * B.Matlabdeki randperm in aynısı Görevi kendisine verilen n sayısına kadar
     * random indexler üretmek
     *
     * @param n
     * @return
     */
    public CMatrix randPerm(int n) {
        double[] m = new double[n];
        ArrayList<Double> v = new ArrayList<Double>();
        for (int i = 0; i < n; i++) {
            v.add(new Double(i));
        }
        for (int i = 0; i < n; i++) {
            int a = new Random().nextInt(n - i);
            m[i] = v.get(a);
            v.remove(a);
        }
        CMatrix ret = new CMatrix(m);
        return ret.clone(this);
    }

    /**
     * B.Matlabdeki randperm in aynısı Görevi kendisine verilen n sayısına kadar
     * random indexler üretmek
     *
     * @return
     */
    public CMatrix randPerm(int from, int to) {
        int n = to - from;
        double[] m = new double[n];
        ArrayList<Double> v = new ArrayList<Double>();
        for (int i = from; i < to; i++) {
            v.add(new Double(i));
        }
        for (int i = 0; i < n; i++) {
            int a = new Random().nextInt(n - i);
            m[i] = v.get(a);
            v.remove(a);
        }
        CMatrix ret = new CMatrix(m);
        return ret.clone(this);
    }

    public int[] randPermInt(int n) {
        int[] m = new int[n];
        ArrayList<Integer> v = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            v.add(new Integer(i));
        }
        for (int i = 0; i < n; i++) {
            int a = new Random().nextInt(n - i);
            m[i] = v.get(a);
            v.remove(a);
        }
        return m;
    }

    public CMatrix permute(int n) {
        return randPerm(n);
    }

    public CMatrix permute(int from, int to) {
        return randPerm(from, to);
    }

    public CMatrix minusScalar(double n) {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = ret.array[i][j] - n;
            }
        }
        ret.name = this.name + "|minus";
        return ret;
    }

    /**
     * n-CMatrix
     *
     * @param n
     * @return
     */
    public CMatrix minusFromScalar(double n) {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = n - ret.array[i][j];
            }
        }
        ret.name = this.name + "|minus";
        return ret;
    }

    public CMatrix addScalar(double n) {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = ret.array[i][j] + n;
            }
        }
        ret.name = this.name + "|add";
        return ret;
    }

    public CMatrix plusScalar(double n) {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = ret.array[i][j] + n;
            }
        }
        ret.name = this.name + "|plus";
        return ret;
    }

    public CMatrix exp() {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.exp(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|exp";
        return ret;
    }

    public CMatrix log() {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.log(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|log";
        return ret;
    }

    public CMatrix logPlusScalar(double n) {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.log(ret.array[i][j] + n);
            }
        }
        ret.name = this.name + "|log";
        return ret;
    }

    public CMatrix log10() {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.log10(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|log10";
        return ret;
    }

    public CMatrix pow(double n) {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.pow(ret.array[i][j], n);
            }
        }
        ret.name = this.name + "|pow";
        return ret;
    }

    public CMatrix sin() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.sin(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|sin";
        return ret;
    }

    public CMatrix asin() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.asin(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|asin";
        return ret;
    }

    /**
     * sinc(x) is a partial function normalized with pi which is defined as |1,
     * t=0 sinc(x) =| |sin(pi*x)/(pi*x) t != 0
     *
     *
     * @return
     */
    public CMatrix sinc() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                if (ret.array[i][j] != 0) {
                    ret.array[i][j] = Math.sin(Math.PI * ret.array[i][j]) / (Math.PI * ret.array[i][j]);
                } else {
                    ret.array[i][j] = 1;
                }

            }
        }
        ret.name = this.name + "|sinc";
        return ret;
    }

    public CMatrix cos() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.cos(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|cos";
        return ret;
    }

    public CMatrix acos() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.acos(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|acos";
        return ret;
    }

    public CMatrix tan() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.tan(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|tan";
        return ret;
    }

    public CMatrix cot() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = 1 / Math.tan(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|cot";
        return ret;
    }

    public CMatrix acot() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = 1 / Math.atan(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|atan";
        return ret;
    }

    public CMatrix atan() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.atan(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|atan";
        return ret;
    }

    public CMatrix tanh() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.tanh(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|tanh";
        return ret;
    }

    public CMatrix sigmoid() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        ret.array = FactoryMatrix.sigmoid(ret.array);
        ret.name = this.name + "|sigmoid";
        return ret;
    }

    public CMatrix sigmoid(double beta) {
        CMatrix ret = this.clone(this);

        ret.image = null;
        ret.array = FactoryMatrix.sigmoid(ret.array, beta);
        ret.name = this.name + "|sigmoid";
        return ret;
    }

    public CMatrix sigmoid(double alpha, double beta) {
        CMatrix ret = this.clone(this);

        ret.image = null;
        ret.array = FactoryMatrix.sigmoid(ret.array, alpha, beta);
        ret.name = this.name + "|sigmoid";
        return ret;
    }

    public CMatrix abs() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.abs(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|abs";
        return ret;
    }

    /**
     * Calculate square root of each element (element wised operation)
     *
     * @return CMatrix
     */
    public CMatrix sqrt() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.sqrt(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|sqrt";
        return ret;
    }

    public CMatrix round() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.round(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|round";
        return ret;
    }

    /**
     * format double values with provided precision
     *
     * @param precision
     * @return
     */
    public CMatrix round(int precision) {
        CMatrix ret = this.clone(this);
        ret.image = null;
        ret.array = FactoryUtils.formatDouble(ret.array, precision);
        ret.name = this.name + "|round";
        return ret;
    }

    public CMatrix toDegrees() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.toDegrees(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|degree";
        return ret;
    }

    public CMatrix toRadians() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = Math.toRadians(ret.array[i][j]);
            }
        }
        ret.name = this.name + "|radians";
        return ret;
    }

    public TMatrixCell max() {
        CMatrix ret = this.clone(this);

        TMatrixCell mc = new TMatrixCell();
        double m = ret.toDoubleArray2D()[0][0];
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                if (m < ret.toDoubleArray2D()[i][j]) {
                    m = ret.toDoubleArray2D()[i][j];
                    mc.value = m;
                    mc.p = new Point(i, j);
                }
            }
        }
        return mc;
    }

    public TMatrixCell min() {
        CMatrix ret = this.clone(this);

        TMatrixCell mc = new TMatrixCell();
        double m = ret.toDoubleArray2D()[0][0];
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                if (m > ret.toDoubleArray2D()[i][j]) {
                    m = ret.toDoubleArray2D()[i][j];
                    mc.value = m;
                    mc.p = new Point(i, j);
                }
            }
        }
        return mc;
    }

    public double sumTotal() {
        CMatrix ret = this.clone(this);
        double d = FactoryMatrix.sumTotal(ret.array);
        return d;
    }

    public double prodTotal() {
        CMatrix ret = this.clone(this);

        double m = 1;
        double[][] d = ret.toDoubleArray2D();
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                m *= d[i][j];
            }
        }
        return m;
    }

    public double meanTotal() {
        double m = this.sumTotal() / (this.getColumnNumber() * this.getRowNumber());
        return m;
    }

    /**
     * equals to meanTotal()
     *
     * @return
     */
    public double getMean() {
        double m = this.sumTotal() / (this.getColumnNumber() * this.getRowNumber());
        return m;
    }

    public double stdTotal() {
        double ret = FactoryUtils.std(this.matrix(":").getColumn(0));
        return ret;
    }

    /**
     * equals to stdTotal()
     *
     * @return
     */
    public double getStd() {
        double ret = FactoryUtils.std(this.matrix(":").getColumn(0));
        return ret;
    }

    /**
     * Sutun bazlı toplama işlemi yapar mxn matrisinin tüm elemanlarını toplamak
     * istiyorsanız sumTotal veya iki defa sum çağırınız
     *
     * @return CMatrix
     */
    public CMatrix sum() {
        double[] r = new double[this.getColumnNumber()];
        CMatrix ret = new CMatrix(r);
        CMatrix cm = this.clone(this).transpose();
        for (int i = 0; i < cm.getRowNumber(); i++) {
            r[i] = FactoryUtils.sum(cm.array[i]);
        }
        ret.setArray(r);
        ret.name = this.name + "|sum";
        return ret;
    }

    /**
     * Sutun bazlı çarpma işlemi yapar mxn matrisinin tüm elemanlarını çarpmak
     * istiyorsanız prodTotal veya iki defa prod çağırınız
     *
     * @return CMatrix
     */
    public CMatrix prod() {
        double[] r = new double[this.getColumnNumber()];
        CMatrix ret = new CMatrix(r);
        CMatrix cm = this.clone(this).transpose();
        for (int i = 0; i < cm.getRowNumber(); i++) {
            r[i] = FactoryUtils.prod(cm.array[i]);
        }
        ret.setArray(r);
        ret.name = this.name + "|sum";
        return ret;
    }

    public CMatrix mean() {
        double[] r = new double[this.getColumnNumber()];
        CMatrix ret = new CMatrix(r);
        CMatrix cm = this.clone(this).transpose();
        for (int i = 0; i < cm.getRowNumber(); i++) {
            r[i] = FactoryUtils.mean(cm.array[i]);
        }
        ret.setArray(r);
        ret.name = this.name + "|mean";
        return ret;
    }

    public CMatrix std() {
        double[] r = new double[this.getColumnNumber()];
        CMatrix ret = new CMatrix(r);
        CMatrix cm = this.clone(this).transpose();
        for (int i = 0; i < cm.getRowNumber(); i++) {
            r[i] = FactoryUtils.std(cm.array[i]);
        }
        ret.setArray(r);
        ret.name = this.name + "|std";
        return ret;
    }

    public CMatrix var() {
        double[] r = new double[this.getColumnNumber()];
        CMatrix ret = new CMatrix(r);
        CMatrix cm = this.clone(this).transpose();
        for (int i = 0; i < cm.getRowNumber(); i++) {
            r[i] = FactoryUtils.var(cm.array[i]);
        }
        ret.setArray(r);
        ret.name = this.name + "|std";
        return ret;
    }

    public CMatrix divideScalar(double n) {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = ret.array[i][j] / n;
            }
        }
        ret.name = this.name + "|divide";
        return ret;
    }

    public CMatrix divideByScalar(double n) {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = n / ret.array[i][j];
            }
        }
        ret.name = this.name + "|divideby";
        return ret;
    }

    public CMatrix dot(CMatrix cm) {
        if (!this.isIdentical(this, cm)) {
            throw new ArithmeticException("Matrixes should be identical in size");
        }
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryMatrix.dot(ret.array, cm.array));
        return ret;
    }

    public CMatrix dotProduct(CMatrix cm) {
//        if (this.getRowNumber() == cm.getRowNumber()) {
//            if (this.getColumnNumber() == cm.getColumnNumber()) {
//                if (cm.getColumnNumber() == 1) {
//                    CMatrix ret = this.clone(this);
//                    ret.setArray(FactoryMatrix.dotProduct(this.array, cm.array));
//                    return ret;
//                }
//            }
//        } else 
        if (FactoryUtils.canBeDotProduct(this.array, cm.array)) {
            CMatrix ret = this.clone(this);
            ret.setArray(FactoryMatrix.dotProduct(this.array, cm.array));
            return ret;
        }
        System.err.println("Matrix size didn't match for dot product");
        return cm;
    }

    public CMatrix getMagnitude() {
        CMatrix ret = this.clone(this);

        ret.array = FactoryMatrix.getMagnitude(ret.array);
        return ret;
    }

    public CMatrix getMagnitude(CMatrix cm) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryMatrix.getMagnitude(cm.array);
        return ret;
    }

    public CMatrix getAngle(CMatrix second) {
        return calculateCosineTheoremWithDotProduct(second);
    }

    public CMatrix calculateCosineTheoremWithDotProduct(CMatrix second) {
        CMatrix ret = this.clone(this);
        double[][] d = new double[1][1];
        d[0][0] = Math.acos(ret.dotProduct(second).getValue() / (ret.getMagnitude().getValue() * second.getMagnitude().getValue())) / Math.PI * 180;
        ret.setArray(d);
        return ret;
    }

    public CMatrix dot(CMatrix cm, Dimension dm) {
        if (!this.isIdentical(this, cm)) {
            System.out.println("Matrixes should be identical in size");
            return this;
        }
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryMatrix.dot(ret.array, cm.array, dm));
        return ret;
    }

    public CMatrix timesScalar(double n) {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = ret.array[i][j] * n;
            }
        }
        ret.name = this.name + "|timesScalar";
        return ret;
    }

//    public CMatrix dot(CMatrix cm) {
//        return multiplyElement(cm);
//    }
    /**
     * Matlab compatible command: element wise multiplication
     *
     * @param cm : second matrix
     *
     * @return CMatrix
     */
    public CMatrix times(CMatrix cm) {
        if (FactoryUtils.isVector(this.array) && FactoryUtils.isVector(cm.array) && FactoryUtils.isSimilarShape(this.array, cm.array)) {
            double d = FactoryUtils.dotVector(this.array, cm.array);
            return CMatrix.getInstance().setArray(new double[]{d});
        }
        if (this.getColumnNumber() != cm.getRowNumber()) {
//            System.out.println("can not multiply please make sure two matrix obey the matrix multiplication rule i.e. column number of first matrix must equal to the coulmnumber of the second matrix");
            throw new InputMismatchException("can not multiply these two matrices please make sure both matrices obey the matrix multiplication rule i.e. column number of first matrix must equal to the colum number of the second matrix");
//            return null;
        }
        CMatrix ret = new CMatrix(this.getRowNumber(), cm.getColumnNumber());
        cm = cm.transpose();
        for (int r = 0; r < ret.getRowNumber(); r++) {
            for (int c = 0; c < ret.getColumnNumber(); c++) {
                ret.array[r][c] = FactoryUtils.multiplyAndSum(this.getRow(r), cm.getRow(c));
            }
        }
        ret.name = this.name + "|times";
        return ret;
    }

    public CMatrix multiplyScalar(double n) {
        CMatrix ret = this.clone(this);

        ret.image = null;
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                ret.array[i][j] = ret.array[i][j] * n;
            }
        }
        ret.name = this.name + "|multiply";
        return ret;
    }

    public CMatrix scale(double n) {
        return multiplyScalar(n);
    }

    public String toString(String var) {
        String s = var + "=\n";
        s += "Matrix of [" + this.getRowNumber() + "x" + this.getColumnNumber() + "]=\n";

        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += this.array[i][j] + "\t";
            }
            s += r + "\n";
        }
        return s;
    }

    public String toStringWithToken(String token) {
        String s = "";

        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += this.array[i][j] + token;
            }
            s += r;
        }
        s = s.substring(0, s.length() - 1);
        return s;
    }

    @Override
    public String toString() {
        String s = "Matrix of [" + this.getRowNumber() + "x" + this.getColumnNumber() + "]=\n";
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += this.array[i][j] + "\t";
            }
            s += r + "\n";
        }
        return s;
    }

    public String toCommaString() {
        String s = "";
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += (this.array[i][j] + "").replace(".", ",") + "\t";
            }
            if (i < this.getRowNumber() - 1) {
                s += r + "\n";
            } else {
                s += r;
            }
        }
        return s;
    }

    public String toCSVString() {
        String s = "";
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += this.array[i][j] + ";";
            }
            s += r + "\n";
        }
        return s;
    }

    public String toCommaStringWithIdentifier() {
        String s = "Matrix of [" + this.getRowNumber() + "x" + this.getColumnNumber() + "]=\n";
        for (int i = 0; i < this.getRowNumber(); i++) {
            String r = "";
            for (int j = 0; j < this.getColumnNumber(); j++) {
                r += (this.array[i][j] + "").replace(".", ",") + "\t";
            }
            s += r + "\n";
        }
//        System.out.println(s);
        return s;
    }

    public CMatrix printlnComma() {
        System.out.println(this.toCommaString());
        return this;
    }

    public CMatrix printlnComma(String s) {
        System.out.println(s + "\n" + this.toCommaString());
        return this;
    }

    /**
     * print each element of CMatrix double[][] data as a Matrix Form
     *
     * @return CMatrix
     */
    public CMatrix println() {
        System.out.println(this.toString());
        return this;
    }

    /**
     * print top 5 rows of CMatrix double[][] data with column names if
     * available
     *
     * @return CMatrix
     */
    public CMatrix head() {
        System.out.println("Matrix of [" + array.length + "x" + array[0].length + "]");
        int max = 5;
        if (this.getRowNumber() < max) {
            max = this.getRowNumber();
        }
        if (columnNames != null && !columnNames.isEmpty()) {
            for (String columnName : columnNames) {
                System.out.print(columnName + "\t");
            }
            System.out.println("");
        }
        if (classLabels != null && !classLabels.isEmpty()) {
            for (int i = 0; i < max; i++) {
                for (int j = 0; j < array[0].length; j++) {
                    System.out.print(FactoryUtils.formatDouble(array[i][j]) + "\t");
                }
                System.out.println(classLabels.get(i));
            }
        } else {
            for (int i = 0; i < max; i++) {
                for (int j = 0; j < array[0].length; j++) {
                    System.out.print(array[i][j] + "\t");

                }
                System.out.println("");
            }
        }
        return this;
    }

    public CMatrix println(String s) {
        System.out.println(toString(s));
        return this;
    }

    /**
     * print the content of the matrix
     *
     * @return
     */
    public CMatrix dump() {
        System.out.println(this.toString());
        return this;
    }

    /**
     * print the content of the matrix by adding extra info on the head
     *
     * @param s
     * @return
     */
    public CMatrix dump(String s) {
        System.out.println(toString(s));
        return this;
    }

    public CMatrix fprintln(String file) {
        FactoryUtils.writeToFile(file, this.toString());
        return this;
    }

    public CMatrix fprintln() {
        FactoryUtils.writeToFile(this.toString());
        return this;
    }

    public CMatrix toNewFile() {
        FactoryUtils.writeToFile(this.toString());
        return this;
    }

    public CMatrix toAppendFile() {
        FactoryUtils.writeOnFile(this.toString());
        return this;
    }

    public CMatrix toNewFileCSV(String file) {
        FactoryUtils.writeToFile(file, this.toCSVString());
        return this;
    }

    public CMatrix toNewFile(String file) {
        FactoryUtils.writeToFile(file, this.toCSVString());
        return this;
    }

    public CMatrix writeToNewFileCSV(String file) {
        toNewFileCSV(file);
        return this;
    }

    public CMatrix writeToNewFile(String file) {
        toNewFile(file);
        return this;
    }

    public CMatrix saveAsNewFileCSV(String file) {
        toNewFileCSV(file);
        return this;
    }

    public CMatrix writeOnFile(String file) {
        toAppendFile(file);
        return this;
    }

    public CMatrix saveOnFile(String file) {
        toAppendFile(file);
        return this;
    }

    public CMatrix saveImage(String file_name) {
        ImageProcess.saveImage(image, file_name);
        return this;
    }

    public CMatrix saveImage() {
        ImageProcess.saveImage(image);
        return this;
    }

    public CMatrix saveImageAtFolder(String folderPath) {
        ImageProcess.saveImageAtFolder(image, folderPath);
        return this;
    }

    /**
     *
     * @param file_path
     * @param learning_type :TLearningType.REGRESSION or
     * TLearningType.CLASSIFICATION
     * @return
     */
    public CMatrix toWekaArff(String file_path, int learning_type) {
        FactoryUtils.writeToArffFile(file_path, array, learning_type);
        return this;
    }

    /**
     *
     * @param file_path
     * @param learning_type :TLearningType.REGRESSION or
     * TLearningType.CLASSIFICATION
     * @return
     */
    public CMatrix toARFF(String file_path, int learning_type) {
        FactoryUtils.writeToArffFile(file_path, array, learning_type);
        return this;
    }

    /**
     *
     * @param file_path
     * @param learning_type :TLearningType.REGRESSION or
     * TLearningType.CLASSIFICATION
     * @return
     */
    public CMatrix writeAsArffFile(String file_path, int learning_type) {
        FactoryUtils.writeToArffFile(file_path, array, learning_type);
        return this;
    }

    public CMatrix toAppendFile(String file) {
        FactoryUtils.writeOnFile(file, this.toString());
        return this;
    }

//    public CMatrix toXMLFile() {
//        FactoryUtils.writeToXML(this.clone(this));
//        return this;
//    }
//
//    public String toXML() {
//        return FactoryUtils.toXML(this.clone(this));
//    }
//
//    public CMatrix fromXML(String s) {
//        return (CMatrix) FactoryUtils.fromXML(s);
//    }
//
//    public CMatrix fromXMLFile() {
//        return (CMatrix) FactoryUtils.fromXMLFile();
//    }
//
//    public void toXMLPrintln() {
//        System.out.println(FactoryUtils.toXML(this.clone(this)));
//    }
    /**
     * B. Matlab deki find komutuna banzer çalışmaktadır. find her zaman 1
     * sütünlu n satırlı sütün matrisi geri dönderir içerik olarak ta sadece
     * index bilgisini tutar
     *
     * @param op TMatrixOperator enum tipindeki sınıfı call eder.
     * @param d taranacak base matris
     * @param x matrisin elemanları neye eşitse
     * @return
     *
     */
    public CMatrix findIndex(TMatrixOperator op, CMatrix d, double x) {
        return op.apply(d, x);
    }

    /**
     * operates as Matlab's find method try to find 1D indexes of the matrix
     * based on the specified matrix operator logical conditions returns cloned
     * matrix indeed found indexes are provided in int[] d parameter object
     *
     * @param op:logical criteria
     * @param x :Target value or matching constant number
     * @return
     */
    public CMatrix findIndex(TMatrixOperator op, double x) {
        CMatrix ret = this.clone(this);

        ret = op.apply(ret, x);
        return ret;
    }

    /**
     * operates as Matlab's find method try to find 1D indexes of the matrix
     * based on the specified matrix operator logical conditions returns cloned
     * matrix indeed found indexes are provided in int[] d parameter object
     *
     * @param op:logical criteria
     * @param x :Target value or matching constant number
     * @return
     */
    public CMatrix findItems(TMatrixOperator op, double x) {
        CMatrix ret = this.clone(this);
        ret = op.apply(ret, x);
        CMatrix items = this.clone(this);
        items = items.cmd(ret.toIntArray1D());
        return items;
    }

    /**
     * Find metodu istenilen bir karşılaştırma işlemi ve karşılaştırmada
     * kullanılacak x değerini matlab matris ifadeleri ile belirli bir sütun
     * veya sub-matrix üzerinde işleyerek bulduğu row ların satır numaralarını
     * 1D vektör olarak geri dönderir. Kullanıcı eğer isterse bu vektörü yani
     * cmatrix nesnesini cmd komutuna parametre olarak gönderip değerleri bir
     * sutun dizisi olarak alabilir.
     *
     *
     * operates as Matlab's find method try to find 1D indexes of the matrix
     * based on the specified matrix operator logical conditions returns cloned
     * matrix indeed found indexes are provided in int[] d parameter object
     *
     * @param op:logical criteria
     * @param x :Target value or matching constant number
     * @return
     */
    public CMatrix findIndex(TMatrixOperator op, double x, String p1, String p2) {
        CMatrix ret = this.clone(this);

        ret = op.apply(ret, x, p1, p2);
        return ret;
    }

    /**
     * adaptive threshold could be performed, operates as Matlab's find method
     * try to find 1D indexes of the matrix based on the specified matrix
     * operator logical conditions returns cloned matrix indeed found indexes
     * are provided in int[] d parameter object
     *
     * @param op:logical criteria
     * @return
     */
    public CMatrix findIndex(TMatrixOperator op, double t1, double t2) {
        CMatrix ret = this.clone(this);

        ret = op.apply(ret, t1, t2);
        return ret;
    }

    /**
     * it is used for detecting the single any object in the image matrix and
     * crop the roi of the object from the matrix. it should be noted that
     * internally it is used nf=nearFactor which you should give as a parameter
     *
     * @param thr:threshold value for average pistachio
     * @param backgroundThr:threshold for background subtraction
     * @param nf:near factor how far object from the edge of the image matrix
     * @return cropped matrix related to the object itself
     */
    public CMatrix getWeightCenteredROI(int thr, int backgroundThr, int nf) {
        double[][] d = CMatrix.this.highPassFilter(this.array, backgroundThr).array;
        d = FactoryUtils.getWeightCenteredROI(d, thr, nf);
        if (d != null) {
            this.array = FactoryMatrix.clone(d);
            CMatrix ret = this.clone(this);

            return ret;
        } else {
            return this;
        }
    }
    
    public TRoi getROIofWeightCenteredObject(int thr, int backgroundThr, int nf) {
        double[][] d = CMatrix.this.highPassFilter(this.array, backgroundThr).array;
        TRoi roi = FactoryUtils.getRoiOfWeightCenteredObject(d, thr, nf);
        return roi;
    }

    public CMatrix getWeightCenteredROI() {
        double[][] d = FactoryUtils.getWeightCenteredROI(this.array);
        if (d != null) {
            this.array = FactoryMatrix.clone(d);
            CMatrix ret = this.clone(this);

            return ret;
        } else {
            return this;
        }
    }

    /**
     * Calculate the pixel area of the object in the scene
     *
     * @param thr: average pixel value of the object, you can determine this
     * value by otsu threshold also
     * @param isTextVisible: whether info will be written or not
     * @return
     */
    public CMatrix getObjectArea(int thr, boolean isTextVisible) {
        this.returnedValue.str = "" + FeatureExtractionPistachio.getPixelArea(this.toDoubleArray2D(), thr);
        if (isTextVisible) {
            System.out.println("Calculated Object Area is:" + this.returnedValue.str);
        }
        return this;
    }

    public CMatrix getObjectArea() {
        this.returnedValue.str = "" + FeatureExtractionPistachio.getPixelArea(this.toDoubleArray2D());
        return this;
    }

    /**
     * Matrix inversion
     *
     * @return
     */
    public CMatrix getInverse() {
        if (this.getRowNumber() != this.getColumnNumber()) {
            System.out.println("Only square matrix has inverse operation, otherwise try to calculate pseudoinverse ");
        }
        Matrix m = new Matrix(array);
        m = m.inverse();
        CMatrix ret = this.clone(this).setArray(m.getArray());
        ret.name = this.name + "|inverse";
        return ret;
    }

    /**
     * Matrix covariance
     *
     * @return covariance matrix
     */
    public CMatrix cov() {
        CMatrix ret = this.clone(this);

        ret = ret.setArray(FactoryMatrix.cov(ret.array));
        ret.name = this.name + "|covariance";
        return ret;
    }

    /**
     * Matrix covariance
     *
     * @return covariance value of only two subsequent column vectors
     */
    public CMatrix covValue() {
        CMatrix ret = this.clone(this);
        double[][] cov_d = FactoryMatrix.cov(ret.array);
        double[] d = {cov_d[0][1]};
        ret = ret.setArray(d);
        ret.name = this.name + "|covariance value";
        return ret;
    }

    /**
     * Matrix correlation coefficient
     *
     * @return correlation coefficient matrix
     */
    public CMatrix corrcoef() {
        CMatrix ret = this.clone(this);
        double[][] corr = FactoryMatrix.corrcoef(ret.array);
        ret = ret.setArray(corr);
        ret.name = this.name + "|correlation coefficient";
        return ret;
    }

    /**
     * Matrix correlation coefficient value
     *
     * @return correlation coefficient value
     */
    public CMatrix corrcoefValue() {
        CMatrix ret = this.clone(this);
        double[][] corr = FactoryMatrix.corrcoef(ret.array);
        double[] d = {corr[0][1]};
        ret = ret.setArray(d);
        ret.name = this.name + "|correlation coefficient value";
        return ret;
    }

    /**
     * Matlab compatible command: Matrix inversion
     *
     * @return CMatrix
     */
    public CMatrix inv() {
        return getInverse();
    }

    /**
     * Matlab compatible command: Matrix pseudo inversion
     *
     * @return CMatrix
     */
    public CMatrix pinv() {
        CMatrix ret = this.clone(this);

        ret = ret.setArray(FactoryMatrix.pinv(ret.array));
        return ret;
    }

    /**
     * Eigen Value Decomposition
     *
     * @return
     */
    public CMatrix getEigenValueDecompistion() {
        Matrix m = new Matrix(array);
        EigenvalueDecomposition eig = m.eig();
        m = eig.getD();
        CMatrix ret = this.clone(this).setArray(m.getArray());
        ret.name = this.name + "|eig";
        return ret;
    }

    /**
     * Matlab compatible command: Eigen Value Decomposition
     *
     * @return CMatrix
     */
    public CMatrix eig() {
        return getEigenValueDecompistion();
    }

    public CMatrix fromWekaMatrix(Matrix m) {
        CMatrix ret = this.clone(this);

        ret.setArray(m.getArray());
        return ret;
    }

    public Matrix toWekaMatrix() {
        return new Matrix(array);
    }

    public CMatrix deleteRow(int n) {
        ArrayList lst = this.toArrayList();
        lst.remove(n);
        return CMatrix.getInstance(lst);
    }

    public CMatrix deleteColumn(int n) {
        ArrayList lst = this.transpose().toArrayList();
        lst.remove(n);
        return CMatrix.getInstance(lst).transpose();
    }

    public CMatrix deleteRows(CMatrix m) {
        int[] p = m.toIntArray1D();
        ArrayList<double[]> lst = toArrayList();
        double[][] objList = new double[p.length][lst.get(0).length];
        for (int i = 0; i < p.length; i++) {
            objList[i] = lst.get(p[i]);
        }
        for (int i = 0; i < p.length; i++) {
            lst.remove(objList[i]);
        }
        CMatrix ret = fromArrayList(lst);
        ret.image = null;
        return ret;
    }

    public CMatrix deleteColumns(CMatrix m) {
        CMatrix ret = this.clone(this);
        int[] p = m.toIntArray1D();
        ArrayList<double[]> lst = this.clone(this).transpose().toArrayList();
        double[][] objList = new double[p.length][lst.get(0).length];
        for (int i = 0; i < p.length; i++) {
            objList[i] = lst.get(p[i]);
        }
        for (int i = 0; i < p.length; i++) {
            lst.remove(objList[i]);
        }
        ret = fromArrayList(lst).transpose();
        ret.image = null;
        return ret;
    }

    public double[] getRow(int i) {
        return FactoryMatrix.clone(array[i]);
    }

    public CMatrix getRowMatrix(int i) {
        return CMatrix.getInstance(FactoryMatrix.clone(array[i]));
    }

    public double[] getColumn(int i) {
        return FactoryMatrix.clone(transpose().array[i]);
    }

    public double[] getLastColumn() {
        return FactoryMatrix.clone(transpose().array[getColumnNumber() - 1]);
    }

    public CMatrix getColumnMatrix(int i) {
        return CMatrix.getInstance(FactoryMatrix.clone(transpose().array[i]));
    }

    /**
     * Sadece i. indexteki sutunun değerlerini parametre ile değiştirir, yeni
     * bir sütün eklemez
     *
     * @param n
     * @param p
     * @return
     */
    public CMatrix setColumn(int n, double[] p) {
        CMatrix ret = this.clone(this).transpose();
        for (int i = 0; i < p.length; i++) {
            ret.array[n][i] = p[i];
        }
        return ret.transpose();
    }

    /**
     * Sadece i. indexteki satırın değerlerini parametre ile değiştirir, yeni
     * bir satır eklemez
     *
     * @param i
     * @param p
     * @return
     */
    public CMatrix setRow(int i, double[] p) {
        CMatrix ret = this.clone(this);

        ret.array[i] = p;
        return ret;
    }

    public CMatrix setXY(int i, int j, double p) {
        CMatrix ret = this.clone(this);

        ret.array[i][j] = p;
        return ret;
    }

    /**
     * parametresiz çağrılırsa matrisin 0,0 elemanını geri gönderir
     *
     * @return double
     */
    public double getValue() {
        return array[0][0];
    }

    /**
     * matrisin row ve column koordinatındaki elemanını geri gönderir.
     *
     * @param row
     * @param column
     * @return double
     */
    public double getValue(int row, int column) {
        return array[row][column];
    }

    public CMatrix imAlphaChannel() {
        return getAlphaChannelColor();
    }

    public CMatrix getAlphaChannelColor() {
        CMatrix ret = this.clone(this);
        ret.image = ImageProcess.getAlphaChannelColor(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix imRedChannel() {
        return getRedChannelColor();
    }

    public CMatrix getRedChannelColor() {
        CMatrix ret = this.clone(this);
        ret.image = ImageProcess.getRedChannelColor(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix imGreenChannel() {
        return getGreenChannelColor();
    }

    public CMatrix getGreenChannelColor() {
        CMatrix ret = this.clone(this);
        ret.image = ImageProcess.getGreenChannelColor(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix imBlueChannel() {
        return getBlueChannelColor();
    }

    public CMatrix getBlueChannelColor() {
        CMatrix ret = this.clone(this);
        ret.image = ImageProcess.getBlueChannelColor(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix resetMatrix() {
//        this.name = name;
//        this.array = FactoryUtils.to2DArrayDouble(ImageProcess.imageToPixels255(image));
//        this.rgbImageArray = FactoryUtils.to3DArrayDouble(ImageProcess.imageToPixels(image));
//        this.image = image;
        CMatrix ret = this.clone(this);

        return ret;
    }

    public ArrayList<double[]> toArrayList() {
        CMatrix cm = this.clone(this);

        ArrayList<double[]> ret = new ArrayList<>();
        for (int i = 0; i < cm.getRowNumber(); i++) {
            ret.add(cm.array[i]);
        }
        return ret;
    }

    public CMatrix fromArrayList(ArrayList<double[]> lst) {
        CMatrix ret = new CMatrix(lst.size(), lst.get(0).length);
        for (int i = 0; i < lst.size(); i++) {
            ret.array[i] = lst.get(i);
        }
        return ret;
    }

    public CMatrix fromList(List lst) {
        CMatrix ret = new CMatrix(lst.toArray());
        return ret;
    }

    /**
     * add certain noise on the matrix elements
     *
     * @param range: how much noise
     * @param number : how many jitter noise points
     *
     * @return CMatrix
     */
    public CMatrix jitter(double range, int number) {
        CMatrix cm = this.clone(this);

        CMatrix ret = new CMatrix(number, cm.getColumnNumber());
        double[][] r = ret.toDoubleArray2D();
        for (int i = 0; i < number; i++) {
            for (int j = 0; j < cm.getColumnNumber(); j++) {
                double n = new Random().nextGaussian() * range;
                r[i][j] = cm.toDoubleArray2D()[0][j] + n;
            }
        }
        ret.setArray(r);
        ret.name = this.name + "|jitter";
        return ret;
    }

    /**
     * add certain noise on the matrix elements
     *
     * @param range: how much noise
     *
     * @return CMatrix
     */
    public CMatrix noise(double range) {
        return jitter(range);
    }

    /**
     * add certain noise on the matrix elements
     *
     * @param range: how much noise
     *
     * @return CMatrix
     */
    public CMatrix jitter(double range) {
        CMatrix ret = this.clone(this);

        double[][] r = ret.toDoubleArray2D();
        for (int i = 0; i < ret.getRowNumber(); i++) {
            for (int j = 0; j < ret.getColumnNumber(); j++) {
                double n = new Random().nextGaussian() * range;
                r[i][j] = ret.toDoubleArray2D()[i][j] + n;
            }
        }
        ret.setArray(r);
        ret.name = this.name + "|jitter";
        return ret;
    }

    /**
     * add certain noise on the matrix elements
     *
     * @param range: how much noise
     *
     * @return CMatrix
     */
    public CMatrix addNoise(double range) {
        return jitter(range);
    }

    /**
     * Row wise randomly re-arrangment of the matrix elements
     *
     * @return CMatrix
     */
    public CMatrix shuffleRows() {
        CMatrix ret = this.clone(this);

        ret.name = this.name + "|shuffleRows";
        int[] rows = ret.randPermInt(ret.getRowNumber());
        ret = ret.row(ret, rows);
        return ret;
    }

    /**
     * Row wise randomly re-arrangment of the matrix elements
     *
     * @return CMatrix
     */
    public CMatrix shuffleRowsWeka() {
        CMatrix ret = this.clone(this);

        ret.name = this.name + "|shuffleRowsWeka";
        ret.wekaInstance.randomize(new Random(1));
        return ret;
    }

    /**
     * Row wise randomly re-arrangment of the matrix elements
     *
     * @return CMatrix
     */
    public CMatrix shuffleRowsWeka(int seed) {
        CMatrix ret = this.clone(this);

        ret.name = this.name + "|shuffleRowsWeka";
        ret.wekaInstance.randomize(new Random(seed));
        return ret;
    }

    /**
     * Column wise randomly re-arrangment of the matrix elements
     *
     * @return CMatrix
     */
    public CMatrix shuffleColumns() {
        CMatrix ret = this.clone(this);

        ret.name = this.name + "|shuffleColumns";
        int[] cols = ret.randPermInt(ret.getColumnNumber());
        ret = ret.column(ret, cols);
        return ret;
    }

    /**
     * Matlab compatible command::read image file
     *
     * @return CMatrix
     */
    public CMatrix imread() {
        return readImage();
    }

    public CMatrix imsave() {
        return saveImage();
    }

    public CMatrix imsave_atFolder(String folderPath) {
        return saveImageAtFolder(folderPath);
    }

    public CMatrix imsave(String path) {
        return saveImage(path);
    }

    /**
     * Matlab compatible command::write image file
     *
     * @return CMatrix
     */
    public CMatrix imwrite() {
        return writeImage();
    }

    public CMatrix writeImage() {
        ImageProcess.writeImage(image);
        return this;
    }

    /**
     * Matlab compatible command::write image file
     *
     * @return CMatrix
     */
    public CMatrix imwrite(String path) {
        return writeImage(path);
    }

    public CMatrix writeImage(String path) {
        ImageProcess.writeImage(image, path);
        return this;
    }

    /**
     * Matlab compatible command:read image file from the provided path
     *
     * @param path:image file path
     *
     * @return CMatrix
     */
    public CMatrix imread(String path) {
        return readImage(path);
    }

    public CMatrix readImage() {
        File fl = ImageProcess.readImage();
        BufferedImage bf = ImageProcess.readImageFromFile(fl);
//        CMatrix ret = this.clone(this);
        if (bf != null) {
            this.image = bf;
//            this.array = FactoryUtils.toDoubleArray(ImageProcess.imageToPixels255(image));
//            ret.array = ImageProcess.imageToPixelsDouble(GrayScale.luminosity(image));
            this.imagePath = fl.getAbsolutePath();
            this.array = ImageProcess.bufferedImageToArray2D(this.image);
//            this.rgbImageArray = FactoryUtils.toTripleArray(ImageProcess.imageToPixels(image));
        }
        return this;
    }

    public CMatrix readImage(String path) {
//        BufferedImage bf = ImageProcess.readImageFromFile(path);
//        if (bf != null) {
//            Path p = Paths.get(path);
//            String fileName = p.getFileName().toString();
//            this.name += "|" + fileName;
//            this.image = bf;
////            this.array = ImageProcess.imageToDoublePixels255(this.image);
//            this.array = ImageProcess.imageToPixelsDouble(GrayScale.luminosity(image));
//            this.imagePath = path;
//        } else {
//            System.err.println("null pointer exception, image could not be loaded properly");
//        }
        this.image = ImageProcess.readImage(path);
        this.array = ImageProcess.bufferedImageToArray2D(this.image);
        this.imagePath = path;
        return this;
    }

    public CMatrix normalizeZScore() {
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryNormalization.normalizeZScore(ret.toDoubleArray2D()));
        return ret;
    }

    /**
     * Matlab compatible command: normalize each columns by zscore normalization
     * technique
     *
     * @return CMatrix
     */
    public CMatrix zscore() {
        return normalizeZScore();
    }

    public CMatrix normalizeMinMax() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        ret.setArray(FactoryNormalization.normalizeMinMax(ret.toDoubleArray2D()));
        return ret;
    }

    /**
     * Matlab compatible command: get minimum and maximum values of each rows
     *
     * @return CMatrix
     */
    public CMatrix minmax() {
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryMatrix.getMinMax(ret.array));
        return ret;
    }

    public CMatrix normalizeWithRange(double min, double max) {
        CMatrix ret = this.clone(this);

        ret.image = null;
        ret.setArray(FactoryNormalization.normalizeWithRange(ret.toDoubleArray2D(), min, max));
        return ret;
    }

    public CMatrix normalizeWithRangeRows(double min, double max) {
        CMatrix ret = this.clone(this).transpose();
        ret.image = null;
        ret.setArray(FactoryNormalization.normalizeWithRange(ret.toDoubleArray2D(), min, max));
        return ret.transpose();
    }

    public CMatrix map(double min, double max) {
        return normalizeWithRange(min, max);
    }

    public CMatrix mapRows(double min, double max) {
        return normalizeWithRangeRows(min, max);
    }

    public CMatrix multiplyElement(CMatrix cm) {
        if (this.getRowNumber() != cm.getRowNumber() || this.getColumnNumber() != cm.getColumnNumber()) {
            System.err.println("Two Matrixes should be the same size");
            return this;
        }
        CMatrix ret = this.clone(this);

        ret.image = null;
        double[][] d1 = ret.array;
        double[][] d2 = cm.array;
        double[][] d3 = new double[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = d1[i][j] * d2[i][j];
            }
        }
        ret.setArray(d3);
        return ret;

    }

    public CMatrix divideElement(CMatrix cm) {
        if (this.getRowNumber() != cm.getRowNumber() || this.getColumnNumber() != cm.getColumnNumber()) {
            System.err.println("Two Matrixes should be the same size");
            return this;
        }
        CMatrix ret = this.clone(this);

        ret.image = null;
        double[][] d1 = ret.array;
        double[][] d2 = cm.array;
        double[][] d3 = new double[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = d1[i][j] / d2[i][j];
            }
        }
        ret.setArray(d3);
        return ret;
    }

    public CMatrix and(CMatrix cm) {
        if (this.getRowNumber() != cm.getRowNumber() || this.getColumnNumber() != cm.getColumnNumber()) {
            System.err.println("Two Matrixes should be the same size");
            return this;
        }
        CMatrix ret = this.clone(this);

        ret.image = null;
        double[][] d1 = ret.array;
        double[][] d2 = cm.array;
        double[][] d3 = new double[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = (int) d1[i][j] & (int) d2[i][j];
            }
        }
        ret.setArray(d3);
        return ret;
    }

    public CMatrix or(CMatrix cm) {
        if (this.getRowNumber() != cm.getRowNumber() || this.getColumnNumber() != cm.getColumnNumber()) {
            System.err.println("Two Matrixes should be the same size");
            return this;
        }
        CMatrix ret = this.clone(this);

        ret.image = null;
        double[][] d1 = ret.array;
        double[][] d2 = cm.array;
        double[][] d3 = new double[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = (int) d1[i][j] | (int) d2[i][j];
            }
        }
        ret.setArray(d3);
        return ret;
    }

    public CMatrix xor(CMatrix cm) {
        if (this.getRowNumber() != cm.getRowNumber() || this.getColumnNumber() != cm.getColumnNumber()) {
            System.err.println("Two Matrixes should be the same size");
            return this;
        }
        CMatrix ret = this.clone(this);

        ret.image = null;
        double[][] d1 = ret.array;
        double[][] d2 = cm.array;
        double[][] d3 = new double[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = (int) d1[i][j] ^ (int) d2[i][j];
            }
        }
        ret.setArray(d3);
        return ret;
    }

    public CMatrix not() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        double[][] d1 = ret.array;
        double[][] d3 = new double[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d1.length; i++) {
            for (int j = 0; j < d1[0].length; j++) {
                d3[i][j] = ~(int) d1[i][j];
            }
        }
        ret.setArray(d3);
        return ret;
    }

    /**
     * Matlab compatible command: transform matrix items 1,0,-1 if greater than
     * 0 and if equals 0 and if smaller than 0, respectively
     *
     *
     * @return CMatrix
     */
    public CMatrix sign() {
        return getSignum();
    }

    /**
     * Matlab compilant command: transform matrix items 1,0,-1 if greater than t
     * and if equals t and if smaller than t, respectively
     *
     * @param t : threshold
     *
     * @return CMatrix
     */
    public CMatrix sign(int t) {
        return getSignum(t);
    }

    /**
     * signum is a sign function which satisfies three conditions |-1 :x less
     * than 0 signum(x)=| 0 :x=0 |+1 :x greater than 0
     *
     * @return
     */
    public CMatrix getSignum() {
        CMatrix ret = this.clone(this);

        ret.image = null;
        double[][] d = ret.array;
        double[][] d1 = new double[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d.length; i++) {
            for (int j = 0; j < d[0].length; j++) {
                d1[i][j] = (i == 0) ? 0 : (i > 0) ? 1 : -1;
            }
        }
        ret.setArray(d1);
        return ret;
    }

    /**
     * transform matrix items 1,0,-1 if greater than t and if equals t and if
     * smaller than t, respectively
     *
     * @param t : threshold
     *
     * @return CMatrix
     */
    public CMatrix getSignum(int t) {
        CMatrix ret = this.clone(this);

        ret.image = null;
        double[][] d = ret.array;
        double[][] d1 = new double[getRowNumber()][getColumnNumber()];
        for (int i = 0; i < d.length; i++) {
            for (int j = 0; j < d[0].length; j++) {
                d1[i][j] = (i > t) ? 1 : (i < t) ? -1 : 0;
            }
        }
        ret.setArray(d1);
        return ret;
    }

    /**
     * Basic Statistics Functions here
     *
     * @return
     */
    public double getInverseDiffMoment() {
        double IDF = 0.0d;
        for (int i = 0; i < getRowNumber(); i++) {
            for (int j = 0; j < getColumnNumber(); j++) {
                IDF += array[i][j] / (1 + (i - j) * (i - j));
            }
        }
        return IDF;
    }

    public CMatrix getContrast(int paramInt) {
        int i;
        int[] contrast = new int[256];
        if (paramInt < 0) {
            int j = 0;
            do {
                i = j > 127 ? 255 - j : j;
                i = (int) (127.0D * Math.pow((i > 0 ? i : 1) / 127.0D, (127 + paramInt) / 127.0D));
                if (i > 255) {
                    i = 255;
                } else if (i < 0) {
                    i = 0;
                }
                contrast[j] = (j > 127 ? 255 - i : i);
                j++;
            } while (j < 256);
        } else {
            int j = 0;
            do {
                i = j > 127 ? 255 - j : j;
                double d = (paramInt == 127) ? 127.0D : (127.0D / (127 - paramInt));
                i = (int) (127.0D * Math.pow(i / 127.0D, d));
                if (i > 255) {
                    i = 255;
                } else if (i < 0) {
                    i = 0;
                }
                contrast[j] = (j > 127 ? 255 - i : i);
                j++;
            } while (j < 256);
        }
        CMatrix ret = this.clone(this);

        ret.setArray(contrast);
        return ret;
    }

    /**
     * As far as we know contrast means dynamic range of the image here dynamic
     * range represents absolute difference value of max and min values
     *
     * @return
     */
    public double getContrast() {
        double contrast = 0.0d;
        double[] hist = getImageHistogramData().toDoubleArray1D();
        double max = 0;
        double min = 0;
        for (int i = 0; i < hist.length; i++) {
            if (hist[i] > 0) {
                min = i;
                break;
            }
        }
        for (int i = hist.length - 1; i > 0; i--) {
            if (hist[i] > 0) {
                max = i;
                break;
            }
        }
        contrast = Math.abs(max - min);
        return contrast;
    }

    /**
     * Matlab compatible command: calculate contrast value
     *
     * @return
     */
    public CMatrix contrast() {
        CMatrix ret = this.clone(this);

        ret.returnedValue.str = "" + getContrast();
        return ret;
    }

    /**
     * Matlab compatible command: calculate contrast value
     *
     * @param k : threshold value
     *
     * @return CMatrix
     */
    public CMatrix contrast(int k) {
        return getContrast(k);
    }

    /**
     * Matlab compatible command: calculate entropy value based on columns
     *
     * @return CMatrix
     */
    public CMatrix entropy() {
        CMatrix ret = this.clone(this);
        ret.setArray(ret.getColumnEntropy());
        ret.returnedValue.str = "" + getEntropy();
        return ret;
    }

    /**
     * calculate entropy values of each columns
     *
     * @return double[]
     */
    public double[] getColumnEntropy() {
        int nc = this.getColumnNumber();
        double[] entropies = new double[nc];
        for (int i = 0; i < nc; i++) {
            entropies[i] = this.cmd(":", "" + i).getEntropy();
        }
        return entropies;
    }

    public double getEntropy() {
        double entropy = 0.0d;
        double[] pdfArray = getPDFData().toDoubleArray1D();
        for (int i = 0; i < pdfArray.length; i++) {
            if (pdfArray[i] >= 0 && pdfArray[i] <= 0.000001) {
                continue;
            }
            entropy += pdfArray[i] * Math.log(pdfArray[i]);
        }
        entropy = -entropy;
        return entropy;
    }

    /**
     * Matlab compatible command: calculate energy value based on columns
     *
     * @return CMatrix
     */
    public CMatrix energy() {
        CMatrix ret = this.clone(this);
        ret.setArray(ret.getColumnEnergy());
        ret.returnedValue.str = "" + getEnergy();
        return ret;
    }

    /**
     * calculate energy values of each columns
     *
     * @return double[]
     */
    public double[] getColumnEnergy() {
        int nc = this.getColumnNumber();
        double[] energies = new double[nc];
        for (int i = 0; i < nc; i++) {
            energies[i] = this.cmd(":", "" + i).getEnergy();
        }
        return energies;
    }

    public double getEnergy() {
        double energy = 0.0d;
        for (int i = 0; i < getRowNumber(); i++) {
            for (int j = 0; j < getColumnNumber(); j++) {
                energy += array[i][j] * array[i][j];
            }
        }
        return energy;
    }

    /**
     * Matlab compatible command: calculate kurtosis value based on columns
     *
     * @return CMatrix
     */
    public CMatrix kurtosis() {
        CMatrix ret = this.clone(this);
        ret.setArray(ret.getColumnKurtosis());
        ret.returnedValue.str = "" + getKurtosis();
        return ret;
    }

    /**
     * calculate energy values of each columns
     *
     * @return double[]
     */
    public double[] getColumnKurtosis() {
        int nc = this.getColumnNumber();
        double[] kurtosis = new double[nc];
        for (int j = 0; j < nc; j++) {
            kurtosis[j] = this.cmd(":", "" + j).getKurtosis();
        }
        return kurtosis;
    }

    public double getKurtosis() {
        int[] nums = toIntArray1D();
        int n = nums.length;
        double mean = FactoryUtils.getMean(nums);
        double deviation = 0.0d;
        double variance = 0.0d;
        double k = 0.0d;

        for (int i = 0; i < n; i++) {
            deviation = nums[i] - mean;
            variance += Math.pow(deviation, 2);
            k += Math.pow(deviation, 4);
        }
        //variance /= (n - 1);
        variance = variance / n;
        if (variance != 0.0) {
            //k = k / (n * variance * variance) - 3.0;
            k = k / (n * variance * variance);
        }
        return k;
    }

    public CMatrix getHistogram() {
        int[] d = this.toIntArray1D();
        int[] ret = ImageProcess.getHistogram(d);
        CMatrix cm = CMatrix.getInstance(ret);

        return cm;
    }

    /**
     * Matlab compatible command: calculate skewness value based on columns
     *
     * @return CMatrix
     */
    public CMatrix skewness() {
        CMatrix ret = this.clone(this);
        ret.setArray(ret.getColumnSkewness());
        ret.returnedValue.str = "" + getSkewness();
        return ret;
    }

    /**
     * calculate skewness values of each columns
     *
     * @return double[]
     */
    public double[] getColumnSkewness() {
        int nc = this.getColumnNumber();
        double[] skewness = new double[nc];
        for (int j = 0; j < nc; j++) {
            skewness[j] = this.cmd(":", "" + j).getSkewness();
        }
        return skewness;
    }

    public double getSkewness() {
        int[] nums = toIntArray1D();
        int n = nums.length;
        double mean = FactoryUtils.getMean(nums);
        double deviation = 0.0d;
        double variance = 0.0d;
        double skew = 0.0d;

        for (int i = 0; i < n; i++) {
            deviation = nums[i] - mean;
            variance += Math.pow(deviation, 2);
            skew += Math.pow(deviation, 3);
        }
        //variance /= (n - 1);
        variance /= n;
        double standard_deviation = Math.sqrt(variance);
        if (variance != 0.0) {
            skew /= (n * variance * standard_deviation);
        }
        return skew;
    }

    public double getAdaptiveExposureScore() {
        double d = getAdaptiveExposureMatrix().sumTotal();
//        if (d >= 0) {
//            d = Math.pow(d, 1.0 / 16);
//        } else {
//            d = -Math.pow(Math.abs(d), 1.0 / 16);
//        }
//        return d + 8;
        return d;
    }

//    public CMatrix getAdaptiveExposureMatrix() {
//        int[] hist = ImageProcess.getHistogram(this.image);
//        CMatrix y = CMatrix.getInstance().vector(0, 255).minusScalar(127).pow(2);
//        CMatrix pdf = CMatrix.getInstance(this.image).getPDFData();
//        CMatrix target = y.multiplyElement(pdf).multiplyElement(y.signum(127)).scale(1.0 / (this.image.getWidth() * this.image.getHeight() / 300));
//        return target;
//    }
    /**
     * adaptive exposure score un çalışma mantığı şu şekilde özetlenebilir
     * hiperspektral görüntülerde veya diğer görüntülerde uç değerler mesela 0
     * ve 255 parlaklık değerleri under expose ve over expose sınırı olduğundan,
     * en uç değerlere en fazla ceza verecek ve ortaya yani 127 griye geldiğinde
     * ise ceza seviyesi çok radikal bir şekilde düşecek bir higher order
     * non-linear bir fonksiyon ile çarpmak veya convolution almak gerekiyor.
     * Hiperspketral görüntüler genellikle hiç bir zaman 0 değerinden
     * başlamadığı için total hesaplandıktan sonra bir eşik değeri ile sağa
     * doğru shift edilmiştir. Diğer görüntüler için bu doğru olmayabilir.
     *
     * @return
     */
    public CMatrix getAdaptiveExposureMatrix() {
        int n = 24;
        CMatrix y1 = CMatrix.getInstance().vector(0, 127).minusScalar(127).pow(n);
        CMatrix y2 = CMatrix.getInstance().vector(128, 255).minusScalar(128).pow(n);
        CMatrix y = y1.cat(2, y2).normalizeMinMax();

//        CMatrix y = CMatrix.getInstance().vector(0, 255).minusScalar(127).pow(8).normalizeMinMax().plot();
        CMatrix pdf = CMatrix.getInstance(this.image).getPDFData();
        CMatrix target = y.multiplyElement(pdf).multiplyElement(y.sign(127));//.plot();//.scale(1.0 / (this.image.getWidth() * this.image.getHeight() / 300));
        return target;
    }

    /**
     * Matlab compatible command: add original to cmx
     *
     * @param cmx : added matrix
     *
     * @return CMatrix
     */
    public CMatrix add(CMatrix cmx) {
        CMatrix ret = this.clone(this);
        int nr = this.getRowNumber();
        int nc = this.getColumnNumber();
        for (int i = 0; i < nr; i++) {
            for (int j = 0; j < nc; j++) {
                ret.array[i][j] = this.array[i][j] + cmx.array[i][j];
            }
        }
        return ret;
    }

    /**
     * row numbers should be identical added matrix should have single column
     * addition takes place on each column of original matrix
     *
     * @param cmx : added matrix
     *
     * @return CMatrix
     */
    public CMatrix addSignal(CMatrix cmx) {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < this.getRowNumber(); i++) {
            for (int j = 0; j < this.getColumnNumber(); j++) {
                ret.array[i][j] = this.array[i][j] + cmx.array[i][0];
            }
        }
        return ret;
    }

    /**
     * Matlab compatible command: Subtract cmx from original matrix
     *
     * @param cmx : subtracted matrix
     *
     * @return CMatrix
     */
    public CMatrix minus(CMatrix cmx) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryUtils.subtract(ret.array, cmx.array);
        return ret;
    }

    public CMatrix difference(CMatrix cmx) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryUtils.subtract(ret.array, cmx.array);
        return ret;
    }

    public CMatrix absDifference(CMatrix cmx) {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.absDifference(ret.array, cmx.array);
        return ret;
    }

    public CMatrix filterMedian(int window_size) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.filterMedian(ret.image, window_size);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    /**
     * Matlab compliant median filter default window size is 3x3
     *
     * @return
     */
    public CMatrix medfilt2() {
        return medfilt2(3);
    }

    /**
     * Matlab compliant median filter with a given window size for 2D image
     * matrix
     *
     * @return
     */
    public CMatrix medfilt2(int window_size) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.filterMedian(ret.image, window_size);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    /**
     * Matlab compatible median filter default window size is 3x3
     *
     * @return
     */
    public CMatrix meanfilt1() {
        return meanfilt1(3);
    }

    /**
     * Matlab compatible median filter with a given window size for 2D image
     * matrix
     *
     * @param window_size: size of the used kernel or window
     * @return
     */
    public CMatrix meanfilt1(int window_size) {
        return filterMean1D(window_size);
    }

    /**
     * apply mean filter
     *
     * @param window_size
     * @return
     */
    public CMatrix filterMean1D(int window_size) {
        CMatrix ret = this.clone(this);

        double[] d = FactoryMatrix.filterMean1D(ret.toDoubleArray1D(), window_size);
        ret.setArray(d);
        return ret;
    }

    /**
     * Matlab compatible median filter default window size is 3x3
     *
     * @return
     */
    public CMatrix medfilt1() {
        return medfilt1(3);
    }

    /**
     * Matlab compatible median filter with a given window size for 2D image
     * matrix
     *
     * @param window_size: size of the used kernel or window
     * @return
     */
    public CMatrix medfilt1(int window_size) {
        return filterMedian1D(window_size);
    }

    public CMatrix filterMedian1D(int window_size) {
        CMatrix ret = this.clone(this);

        double[] d = FactoryMatrix.filterMedian1D(ret.toDoubleArray1D(), window_size);
        ret.setArray(d);
        return ret;
    }

    public CMatrix filterGaussian(int window_size) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.filterGaussian(ret.image, window_size);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix filterMembershipFunction(CMatrix cm) {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryMatrix.filterMembershipFunction(ret.array, cm.toDoubleArray1D());
        ret.array = d;
        return ret;
    }

    /**
     * apply mean filter
     *
     * @param window_size
     * @return
     */
    public CMatrix filterMean(int window_size) {
        CMatrix ret = this.clone(this);
        ret.image = ImageProcess.filterMean(ret.image);
        ret.array = ImageProcess.bufferedImageToArray2D(ret.image);
        return ret;
    }

    /**
     * apply mean filter
     *
     * @param window_size
     * @return
     */
    public CMatrix filterMotionBlur() {
        CMatrix ret = this.clone(this);
        ret.image = ImageProcess.filterMotionBlur(ret.image);
        ret.array = ImageProcess.bufferedImageToArray2D(ret.image);
        return ret;
    }

    /**
     * Matlab compatible mean filter or average filter for 2D image matrix with
     * a given size of window
     *
     * @param window_size
     * @return
     */
    public CMatrix filter2(int window_size) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.filterMean(ret.image, window_size);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    /**
     * Matlab compliant mean filter or average filter for 2D image matrix
     *
     * @return
     */
    public CMatrix filter2() {
        return filter2(3);
    }

    /**
     * column wised number of peaks in the matrix signals
     *
     * @return CMatrix
     */
    public CMatrix getNumberOfPeaks() {
        CMatrix ret = this.clone(this);

        //List<Map<Integer, Double>> lst = FactoryPeakDetector.getPeaks(returnedValue.array[0], d);
        double[] peaks = FactoryUtils.getNumberOfPeaks(ret.array);
        ret = new CMatrix(peaks);
        return ret.transpose();
    }

    /**
     * column wised number of peaks in the matrix signals
     *
     * @return
     */
    public CMatrix getAverageNumberOfPeaks() {
        CMatrix ret = this.clone(this);

        int length = ret.array.length;
        //List<Map<Integer, Double>> lst = FactoryPeakDetector.getPeaks(returnedValue.array[0], d);
        double[] peaks = FactoryUtils.getNumberOfPeaks(ret.array);
        for (int i = 0; i < peaks.length; i++) {
            peaks[i] = peaks[i] / length;
        }
        ret = new CMatrix(peaks);
        return ret.transpose();
    }

    public CMatrix getAverageTotalMovement() {
        CMatrix ret = this.clone(this);

        int length = ret.array.length;
        double[] movs = FactoryUtils.getTotalMovement(ret.array);
        for (int i = 0; i < movs.length; i++) {
            movs[i] = movs[i] / length;
        }
        ret = new CMatrix(movs);
        return ret.transpose();
    }

    /**
     * compute combination of n subset of the string array you can get the
     * result by means of combinationPairs array defined in CMatrix as public
     * access modifier
     *
     * @param lst
     * @param n
     * @return
     */
    public CMatrix combinationPairs(String[] lst, int n) {
        CMatrix ret = this.clone(this);
        String[] s = FactoryCombination.getCombination(lst, n);
        ret.combinationPairs = s;
        return ret;
    }

    /**
     * compute combination of n subset of the char array you can get the result
     * by means of combinationPairs array defined in CMatrix as public access
     * modifier
     *
     * @param lst
     * @param n
     * @return
     */
    public CMatrix combinationPairs(char[] lst, int n) {
        CMatrix ret = this.clone(this);
        String[] s = FactoryCombination.getCombination(FactoryMatrix.toStringArray(lst), n);
        ret.combinationPairs = s;
        return ret;
    }

    /**
     * compute permutation of n subset of the string array you can get the
     * result by means of permutationPairs array defined in CMatrix as public
     * access modifier
     *
     * @param lst
     * @param n
     * @return
     */
    public CMatrix permutationPairs(char[] lst, int n) {
        CMatrix ret = this.clone(this);

        List<String> list = new ArrayList();
        String[] ss = FactoryCombination.getCombination(FactoryMatrix.toStringArray(lst), n);
        int k = 0;
        for (int i = 0; i < ss.length; i++) {
            String[] s = FactoryPermutation.getPermutation(ss[i].replace(",", "").toCharArray());
            for (int j = 0; j < s.length; j++) {
                list.add(s[j]);
            }
        }
        ret.permutationPairs = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            ret.permutationPairs[i] = list.get(i);
        }
        return ret;
    }

    /**
     * Matlab compatible command: calculate C(n,k) value
     *
     * @param n : size of the superset
     * @param k : size of the subset
     * @return CMatrix
     */
    public CMatrix nchoosek(int n, int k) {
        CMatrix ret = this.clone(this);

        if (n < k) {
            System.out.println("for combination calculation first parameter should greater thand second one");
            ret.returnedValue.str = -1 + "";
        }

//        ret.returnedValue.str = "" + (int) (FactoryUtils.fact(n) / (FactoryUtils.fact(n - k) * FactoryUtils.fact(k)));
        ret.returnedValue.str = "" + FactoryUtils.combination(n, k);
        return ret;
    }

    /**
     * return the biggest size of the dimension in the matrix
     *
     * @return
     */
    public int getMaxDimSize() {
        int max = this.getColumnNumber();
        if (this.getRowNumber() > max) {
            return this.getRowNumber();
        }
        return max;
    }

    /**
     * return the biggest size of the dimension in the matrix
     *
     * @return
     */
    public int maxsize() {
        return getMaxDimSize();
    }

    /**
     * return the biggest size of the dimension in matrix parameter cm
     *
     * @param cm : CMatrix
     * @return biggest dimension size
     */
    public int getMaxDimSize(CMatrix cm) {
        int max = cm.getColumnNumber();
        if (cm.getRowNumber() > max) {
            return cm.getRowNumber();
        }
        return max;
    }

    /**
     * return the biggest size of the dimension in matrix parameter cm
     *
     * @param cm : CMatrix
     * @return biggest dimension size
     */
    public int maxsize(CMatrix cm) {
        return getMaxDimSize(cm);
    }

//    
//    public CMatrix allcomb(int n){
//        
//    }
    /**
     * Matlab compatible command:
     *
     * Matlabdaki cat yani concatenate ile benzemektedir ayrıca merge metodunun
     * birebir aynısıdır matlab uyumluluğu için eklenmiştir.
     *
     * Farkı şudur Matlabdaki cat fonksiyonu, dim paramtresinden sonra iki adet
     * matris alır bunları ekler eğer dim 1 ise horzcat, 2 ise vertcat
     * fonksiyonlarının işini görür veya dim 1 ise [A B] yapar 2 ise [A;B] yapar
     *
     * OCL de ise cat sadece bir matrise ihtiyaç duyar, çünkü this de zaten
     * birinci matris vardır
     *
     * @param dim 1=yatay ekleme; 2=dikey ekleme
     * @param cm eklemek istenilen matris sona eklenir(note that matrix
     * dimension should be appropriate along with the dimension) i.e. if
     * dimension is set to 1 means that horizontal concetanation is desired, so
     * matrix number of rows should be identical to eachother. And vice versa.
     *
     * @return CMatrix
     */
    public CMatrix cat(int dim, CMatrix cm) {
//        String[] both = Arrays.copyOf(first, first.length + second.length);
//        System.arraycopy(second, 0, both, first.length, second.length);

        CMatrix ret = this.clone(this);

        if (dim == 1) {
            if (ret.getRowNumber() != cm.getRowNumber()) {
                System.out.println("Matrix first dimension (number of rows) should be the same as the base matrix");

                return ret;
            }
            ret = ret.transpose();
            cm = cm.transpose();
            ArrayList<double[]> lst = new ArrayList<>();
            for (int i = 0; i < ret.getRowNumber(); i++) {
                lst.add(ret.array[i]);
            }
            for (int i = 0; i < cm.getRowNumber(); i++) {
                lst.add(cm.array[i]);
            }
            double[][] d = new double[lst.size()][ret.getColumnNumber()];
            for (int i = 0; i < lst.size(); i++) {
                d[i] = lst.get(i);
            }
            CMatrix r = CMatrix.getInstance(d).transpose();
            //r.image=ret.image;
            r.image = null;
            return r;
        }
        if (dim == 2) {
            if (ret.getColumnNumber() != cm.getColumnNumber()) {
                System.out.println("Matrix second dimension (number of columns) should be the same as the base matrix");

                return ret;
            }
            ArrayList<double[]> lst = new ArrayList<>();
            for (int i = 0; i < ret.getRowNumber(); i++) {
                lst.add(ret.array[i]);
            }
            for (int i = 0; i < cm.getRowNumber(); i++) {
                lst.add(cm.array[i]);
            }
            double[][] d = new double[lst.size()][ret.getColumnNumber()];
            for (int i = 0; i < lst.size(); i++) {
                d[i] = lst.get(i);
            }
            CMatrix r = CMatrix.getInstance(d);
            r.image = null;
            return r;
        }
        ret.image = null;
        return ret;
    }

    /**
     * Matlab Compatibility
     *
     *
     * Eklenecek matrisi başa alıp ekler normal cat ise sona ekler Matlabdaki
     * cat yani concatenate fonksiyonuna banzer farkı şudur Matlabdaki cat
     * fonksiyonu, dim paramtresinden sonra iki adet matris alır bunları ekler
     * eğer dim 1 ise horzcat, 2 ise vertcat fonksiyonlarının işini görür veya
     * dim 1 ise [A B] yapar 2 ise [A;B] yapar OCL de ise cat sadece bir matrise
     * ihtiyaç duyar, çünkü this de zaten birinci matris vardır.
     *
     * @param dim :1=horizontal ; 2=vertical
     * @param cm :matrix that is desired to concatenate tries to concatenate at
     * the begining of the original matrix (note that matrix dimension should be
     * appropriate along with the dimension) i.e. if dimension is set to 1 means
     * that horizontal concetanation is desired, so matrix number of rows should
     * be identical to eachother. And vice versa.
     *
     * @return CMatrix
     */
    public CMatrix catFirst(int dim, CMatrix cm) {
        CMatrix ret = this.clone(this);

        if (dim == 1) {
            if (ret.getRowNumber() != cm.getRowNumber()) {
                System.out.println("Matrix first dimension (number of rows) should be the same as the base matrix");

                return ret;
            }
            ret = ret.transpose();
            cm = cm.transpose();
            ArrayList<double[]> lst = new ArrayList<>();
            for (int i = 0; i < cm.getRowNumber(); i++) {
                lst.add(cm.array[i]);
            }
            for (int i = 0; i < ret.getRowNumber(); i++) {
                lst.add(ret.array[i]);
            }
            double[][] d = new double[lst.size()][ret.getColumnNumber()];
            for (int i = 0; i < lst.size(); i++) {
                d[i] = lst.get(i);
            }
            CMatrix r = CMatrix.getInstance(d).transpose();
            return r;
        }
        if (dim == 2) {
            if (ret.getColumnNumber() != cm.getColumnNumber()) {
                System.out.println("Matrix second dimension (number of columns) should be the same as the base matrix");

                return ret;
            }
            ArrayList<double[]> lst = new ArrayList<>();
            for (int i = 0; i < cm.getRowNumber(); i++) {
                lst.add(cm.array[i]);
            }
            for (int i = 0; i < ret.getRowNumber(); i++) {
                lst.add(ret.array[i]);
            }
            double[][] d = new double[lst.size()][ret.getColumnNumber()];
            for (int i = 0; i < lst.size(); i++) {
                d[i] = lst.get(i);
            }
            CMatrix r = CMatrix.getInstance(d);
            return r;
        }

        return ret;
    }

    /**
     * Matlab compatible command: for Matlab Compatibility initialize timer
     * (System.nanoTime() is called for perfect calculation of elapsed time)
     *
     * @return CMatrix
     */
    public CMatrix tic() {
        currentTime = System.nanoTime();
        return this;
    }

    /**
     * Matlab compatible command: for Matlab Compatibility print elapsed time
     * from tic() to toc() in second (System.nanoTime() is called for perfect
     * calculation of elapsed time)
     *
     * @return CMatrix
     */
    public CMatrix toc() {
        long t2 = System.nanoTime();
        double elapsed = (t2 - currentTime) / 1000000.0;
        System.out.println("Elapsed Time:" + elapsed + " ms");
        currentTime = System.nanoTime();
        return this;
    }

    public CMatrix toc(String msg) {
        long t2 = System.nanoTime();
        double elapsed = (t2 - currentTime) / 1000000.0;
        System.out.println(msg + " Elapsed Time:" + elapsed + " miliSecond");
        currentTime = System.nanoTime();
        return this;
    }

    /**
     * Matlab compatible command: compute gauss (normal) membership function for
     * a given mean and standart deviation values
     *
     * @param sigma : standart deviation value
     * @param mean : Mean value
     * @return CMatrix
     */
    public CMatrix gaussmf(double sigma, double mean) {
        CMatrix ret = this.clone(this);

        ret = ret.transpose();
        for (int i = 0; i < ret.getRowNumber(); i++) {
            ret.array[i] = FactoryUtils.gaussian(ret.array[i], sigma, mean);
        }
        return ret.transpose();
    }

    /**
     * Matlab compatible command:Resize the matrix to desired width and height
     * values w:width h:height
     *
     * @param w : width
     * @param h : height
     * @return CMatrix
     */
    public CMatrix imresize(int w, int h) {
        CMatrix ret = this.clone(this);
        if (ret.image == null) {
            ret.image = ImageProcess.pixelsToImageGray(ret.array);
        }
        ret.image = ImageProcess.resize(ret.image, w, h);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    public CMatrix imresizeSmooth(int w, int h) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.resizeSmooth(image, w, h);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    public CMatrix imresize(CSize c) {
        return imresize(c.width, c.height);
    }

    /**
     * resize image with ratio. ie. if ratio is 0.5 it scales image to half size
     * if ratio is 2 it scales image to double size
     *
     * @param ratio
     * @return
     */
    public CMatrix imresize(double ratio) {
        int w = (int) (this.getColumnNumber() * ratio);
        int h = (int) (this.getRowNumber() * ratio);
        return imresize(w, h);
    }

    public CMatrix imblend(CMatrix cm, double alpha) {
        return overlay(cm, alpha);
    }

    public CMatrix imblend(CMatrix cm, CPoint cp) {
        return overlay(cm, cp);
    }

    public CMatrix imblend(CMatrix cm, CPoint cp, double alpha) {
        return overlay(cm, cp);
    }

    /**
     * Matlab compatible command:Resize the matrix to desired width and height
     * values
     *
     * @param w:width
     * @param h:height
     * @return CMatrix //
     */
//    public CMatrix resize(int w, int h) {
//        return imresize(w, h);
//    }
    public CMatrix resize(int n) {
        CMatrix ret = this.clone(this);
        double[][] d = FactoryMatrix.resize(ret.array, n);
        ret.setArray(d);
        return ret;
    }

//    public CMatrix resize(CSize c) {
//        return imresize(c.width, c.height);
//    }
    /**
     * Matlab compatible command: rotate image with desired theta angle
     *
     * @param theta
     * @return CMatrix
     */
    public CMatrix imrotate(double theta) {
        CMatrix ret = this.clone(this);

        if (ret.image == null) {
            ret.image = ImageProcess.pixelsToImageGray(ret.array);
        }
        ret.image = ImageProcess.rotateImage(ret.image, theta);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    /**
     * Matlab compatible command: rotate image around CPoint with desired theta
     * angle theta is not a radian type
     *
     * @param theta
     * @return CMatrix
     */
    public CMatrix imrotate(CPoint cp, double theta) {
        CMatrix ret = this.clone(this);

        if (ret.image == null) {
            ret.image = ImageProcess.pixelsToImageGray(ret.array);
        }
        ret.image = ImageProcess.rotateImage(ret.image, cp, theta);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    /**
     * Extract ring projection features (size:width/2) prerequisites: image
     * should be square stepSize=1 by default
     *
     * @return 1 dimensional ring projection data with the length of
     * imagewidth/2
     */
    public CMatrix extractFeatureRingProjection() {
        return extractFeatureRingProjection(1);
    }

    /**
     * Extract ring projection features (size:width/2) prerequisites: image
     * should be square
     *
     * @param stepSize
     * @return 1 dimensional ring projection data
     */
    public CMatrix extractFeatureRingProjection(int stepSize) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.pixelsToImageGray(FactoryUtils.toIntArray2D(ret.array));
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        double[] d = FeatureExtractionRingProjection.getRingProjection(ret.array, stepSize);
        double[][] m = new double[1][d.length];
        m[0] = d;
        ret.array = m;
        return ret.transpose();
    }

    public CMatrix extractFeatureLBP2D(boolean isRegular) {
        CMatrix ret = this.clone(this);

        int[] d = FeatureExtractionLBP.getLBP(FactoryUtils.toIntArray2D(ret.array), isRegular);
        ret.array = new CMatrix(d).array;

        return ret;
    }

    public CMatrix extractFeatureLBP1D(int N, boolean isRegular) {
        CMatrix ret = this.clone(this);

        int[] d = FeatureExtractionLBP.getLBP(ret.toDoubleArray1D(), N, isRegular);
        ret = new CMatrix(d);

        return ret;
    }

    public CMatrix readFile(String path) {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryUtils.readFromFile(path, ",");
        ret.array = d;
        ret.image = ImageProcess.pixelsToImageGray(d);

        return ret;
    }

    public CMatrix readFile(String path, String token) {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryUtils.readFromFile(path, token);
        ret.array = d;
        ret.image = ImageProcess.pixelsToImageGray(d);

        return ret;
    }

    /**
     * Matlab compatible command: read txt file which contains comma seperated
     * double matrix
     *
     * @param path:file path
     * @return CMatrix
     */
    public CMatrix importdata(String path) {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryUtils.readFromFile(path, ",");
        ret.array = d;
        ret.image = ImageProcess.pixelsToImageGray(d);

        return ret;
    }

    /**
     * Matlab compatible command: read txt file which contains token seperated
     * double matrix
     *
     * @param path:file path
     * @param token: it can be space, comma or semicolon or any arbitrary string
     * value for separation
     * @return CMatrix
     */
    public CMatrix importdata(String path, String token) {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryUtils.readFromFile(path, token);
        ret.array = d;
        ret.image = ImageProcess.pixelsToImageGray(d);

        return ret;
    }

    /**
     * perform Canny Edge Detection operator recommended parameters 0.3f, 1.0f,
     * 2.5f, 3, false
     *
     * @param lowThreshold
     * @param highThreshold
     * @param gaussianKernelRadious
     * @param guassianKernelWidth
     * @param isContrastNormalized
     * @return
     */
    public CMatrix detectEdgeCanny(
            float lowThreshold,
            float highThreshold,
            float gaussianKernelRadious,
            int guassianKernelWidth,
            boolean isContrastNormalized) {

        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.pixelsToImageGray(ImageProcess.imageToPixelsDouble(ImageProcess.edgeDetectionCanny(ret.image, lowThreshold, highThreshold, gaussianKernelRadious, guassianKernelWidth, isContrastNormalized)));
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

//    /**
//     * perform Canny Edge Detection operator recommended parameters 0.3f, 1.0f,
//     * 2.5f, 3, false
//     *
//     * @return
//     */
//    public CMatrix detectEdgeCanny() {
//        CMatrix returnedValue = this.clone(this); lastCM=ret; 
//        returnedValue.image = ImageProcess.pixelsToBufferedImage255(ImageProcess.imageToPixels255Double(ImageProcess.edgeDetectionCanny(returnedValue.image, 0.3f, 1.0f, 2.5f, 3, false)));
//        returnedValue.array = ImageProcess.imageToPixels255Double(returnedValue.image);
//        return returnedValue;
//    }
//
    /**
     * perform Soble Edge Detection operator
     *
     *
     * @return
     */
    public CMatrix edgeDetectionSobel(int thr) {
        CMatrix ret = this.clone(this);

//        SobelEdgeDetector sob = new SobelEdgeDetector(ImageProcess.imageToPixels255Double(returnedValue.image));
        SobelEdgeDetector sob = new SobelEdgeDetector(ret.array);
        ret.array = sob.process(thr);
        ret.image = ImageProcess.pixelsToImageGray(ret.array);

        return ret;
    }

    /**
     * perform Canny Edge Detection operator recommended parameters 0.3f, 1.0f,
     * 2.5f, 3, false
     *
     * @return
     */
    public CMatrix edgeDetectionCanny() {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.pixelsToImageGray(ImageProcess.imageToPixelsDouble(ImageProcess.edgeDetectionCanny(ret.image, 0.3f, 1.0f, 2.5f, 3, false)));
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    /**
     * perform Musa Edge Detection operator recommended parameters
     *
     * @param thr:threshold value
     * @return
     */
    public CMatrix edgeDetectionMusa(int thr) {
        CMatrix ret = this.clone(this);

        ret.array = ImageProcess.edgeDetectionMusa(array, thr);
        ret.image = ImageProcess.pixelsToImageGray(ret.array);

        return ret;
    }

    /**
     * binarize image based on otsu method
     *
     * @return
     */
    public CMatrix binarizeOtsu() {
        CMatrix ret = this.clone(this);

        int thr = ImageProcess.getOtsuTresholdValue(ret.image);
//        System.out.println("otsu threshold:"+thr);
        ret.image = ImageProcess.binarizeGrayScaleImage(ret.array, thr);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    /**
     * draw a specified color line onto image from point1 to point 2
     *
     * @param r1
     * @param c1
     * @param r2
     * @param c2
     * @param color
     * @return
     */
    public CMatrix drawLine(int r1, int c1, int r2, int c2, int th, Color color) {
        CMatrix ret = this.clone(this);
        if (ret.image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            ret.image = ImageProcess.drawLine(ret.image, r1, c1, r2, c2, th, color);
            ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        } else {
            ret.image = ImageProcess.drawLine(ret.image, r1, c1, r2, c2, th, color);
        }
        return ret;
    }

    /**
     * draw a text string with the specified color onto image use imshow to
     * visualize
     *
     * @param msg
     * @param r
     * @param c
     * @param angle : should be Math.Pi unit
     * @param color
     * @return
     */
    public CMatrix drawString(String msg, int r, int c, double angle, Color color) {
        CMatrix ret = this.clone(this);

        Graphics2D g2d = (Graphics2D) ret.image.getGraphics();
        g2d.setColor(color);
        g2d.drawString(msg, c, r);
//        AffineTransform orig = g2d.getTransform();
//        g2d.rotate(angle);
//        g2d.drawString(msg, c, r);
//        g2d.setTransform(orig);

        return ret;
    }

//    /**
//     * draw a specified color line onto image from point1 to point 2 use imshow
//     * to visualize
//     *
//     * @param p1
//     * @param p2
//     * @param color
//     * @return
//     */
//    public CMatrix drawLine(CPoint p1, CPoint p2,int th, Color color) {
//        return drawLine(p1.row, p1.column, p2.row, p2.column,th, color);
//    }
    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param thickness
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawRect(int r, int c, int w, int h, int thickness, Color color) {
        CMatrix ret = this.clone(this);

        if (ret.image == null) {
            ret.image = ImageProcess.pixelsToImageColor(array);
        }
        ret.image = ImageProcess.drawRectangle(ret.image, r, c, w, h, thickness, color);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param rect:CRectangle
     * @param thickness:thickness
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawRect(CRectangle rect, int thickness, Color color) {
        return drawRect(rect.row, rect.column, rect.width, rect.height, thickness, color);
    }

    /**
     * draw a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawRoundRect(int r, int c, int w, int h, int aw, int ah, int thickness, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.drawRoundRectangle(ret.image, r, c, w, h, aw, ah, thickness, color);

        return ret;
    }

    /**
     * fill a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillRoundRect(int r, int c, int w, int h, int aw, int ah, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.fillRoundRectangle(ret.image, r, c, w, h, aw, ah, color);

        return ret;
    }

    /**
     * draw a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix draw3DRect(int r, int c, int w, int h, int aw, int ah, int thickness, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.draw3DRectangle(ret.image, r, c, w, h, thickness, color);

        return ret;
    }

    /**
     * fill a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fill3DRect(int r, int c, int w, int h, int aw, int ah, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.fill3DRectangle(ret.image, r, c, w, h, color);

        return ret;
    }

    /**
     * draw a specified color polygon onto image use imshow to visualize
     *
     * @return
     */
    public CMatrix drawPolygon(Polygon p, int thickness, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.drawPolygon(ret.image, p, thickness, color);

        return ret;
    }

    /**
     * fill a specified color round rectangle onto image from point1 to point 2
     * use imshow to visualize
     *
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillPolygon(Polygon p, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.fillPolygon(ret.image, p, color);

        return ret;
    }

    /**
     * draw a specified color shape use imshow to visualize
     *
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawShape(java.awt.Shape sh, int thickness, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.drawShape(ret.image, sh, thickness, color);

        return ret;
    }

    /**
     * fill a specified color shape use imshow to visualize
     *
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillShape(java.awt.Shape sh, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.fillShape(ret.image, sh, color);

        return ret;
    }

    /**
     * draw a specified color arc use imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawArc(int r, int c, int w, int h, int sa, int aa, int thickness, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.drawArc(ret.image, r, c, w, h, sa, aa, thickness, color);

        return ret;
    }

    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillRect(int r, int c, int w, int h, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.fillRectangle(ret.image, r, c, w, h, color);

        return ret;
    }

    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix drawOval(int r, int c, int w, int h, int thickness, Color color) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.drawOval(ret.image, r, c, w, h, thickness, color);

        return ret;
    }

    /**
     * draw a specified color rectangle onto image from point1 to point 2 use
     * imshow to visualize
     *
     * @param r:row
     * @param c:column
     * @param w:width
     * @param h:height
     * @param color:Color.RED i.e.
     * @return
     */
    public CMatrix fillOval(int r, int c, int w, int h, Color color) {
        CMatrix ret = this.clone(this);

        Graphics2D g2d = (Graphics2D) ret.image.getGraphics();
        g2d.setColor(color);
        g2d.fillOval(c, r, w, h);

        return ret;
    }

//    /**
//     * draw a specified color rectangle onto image from point1 to point 2 use
//     * imshow to visualize
//     *
//     * @param p1
//     * @param p2
//     * @param color
//     * @return
//     */
//    public CMatrix drawRect(CPoint p1, int w, int h,int th, Color color) {
//        return drawRect(p1.row, p1.column, w, h,th, color);
//    }
    /**
     * convert to original image type to desired type
     *
     * @param newType:BufferedImage types
     * @return
     */
    public CMatrix toNewColorSpace(int newType) {
        CMatrix ret = this.clone(this);

        if (ret.image == null) {
            ret.image = ImageProcess.pixelsToImageGray(FactoryUtils.toIntArray2D(array));
        }
        ret.image = ImageProcess.toNewColorSpace(ret.image, newType);
//        ret.array = ImageProcess.imageToPixels255Double(ret.image);

        return ret;
    }

    /**
     * Discrete Cosine Transform Note that width and height of the matrix or
     * image should be 8's power
     *
     * @return
     */
    public CMatrix transformDCT() {
        CMatrix ret = this.clone(this);

        if (ret.image == null) {
            ret.image = ImageProcess.pixelsToImageGray(ret.array);
        }
        ret.image = ImageProcess.DCT(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    /**
     * Matlab compatible command: Discrete Cosine Transform, Note that width and
     * height of the matrix or image should be 8's power
     *
     * @return CMatrix
     */
    public CMatrix dct() {
        return transformDCT();
    }

    /**
     * B. All the well known transfer/transform/filter functions should be here
     */
    /**
     * Medikal Görüntülemedeki Computed Tomograpghy nin radon transferi matrisi
     * sinograph eğrilerine dönüştürür
     *
     * @param numberOfAngles
     * @param numberOfProjections
     * @return
     */
    public CMatrix transformRadonForward(int numberOfAngles, int numberOfProjections) {
        CMatrix ret = this.clone(this);

        ret.array = TransformRadon.forwardProjection(ret.array, numberOfAngles, numberOfProjections);
//        returnedValue.array=FactoryNormalization.normalizeWithRange(returnedValue.array,0,255);

        return ret;
    }

    /**
     * Medikal Görüntülemedeki Computed Tomograpghy nin radon transferinin tersi
     * işlemi sinograph eğrilerinden asıl görüntüye dönüştürür
     *
     * @param imgSize
     * @return
     */
    public CMatrix transformRadonBackward(int imgSize) {
        CMatrix ret = this.clone(this);

        ret.array = TransformRadon.backwardProjection(ret.array, imgSize);

        return ret;
    }

    /**
     * calculates the fast fourier transform of the real signal. Only positive
     * frequencies are available.
     *
     * @return
     */
    public CMatrix transformFFT() {
        CMatrix ret = this.clone(this).transpose();
        TransformFFT fft = new TransformFFT(ret.getColumnNumber());
        for (int i = 0; i < ret.getRowNumber(); i++) {
            ret.array[i] = fft.calculateFFTMagnitude(ret.array[i]);
        }
        return ret.transpose();
    }

    /**
     * Matlab compatible calculates the fast fourier transform of the real
     * signal. Only positive frequencies are available.
     *
     * @return
     */
    public CMatrix fft() {
        return transformFFT();
    }

    /**
     * Matlab compatible command: values greater than threshold 't' are passed
     *
     * @param d:input matrix
     * @param t:threshold value
     * @return CMatrix
     */
    public CMatrix highPassFilter(double[][] d, int t) {
        CMatrix ret = this.clone(this);

        ret.array = ImageProcess.highPassFilter(ret.array, t);

        return ret;
    }

    /**
     * Matlab compatible command: values greater than threshold 't' are passed
     *
     * @param t:threshold value
     * @return CMatrix
     */
    public CMatrix highPassFilter(int t) {
        CMatrix ret = this.clone(this);

        ret.array = ImageProcess.highPassFilter(ret.array, t);

        return ret;
    }

    public double getRoiMean(double[][] d, CPoint[] p) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public CMatrix thresholdOtsu() {
        return binarizeOtsu();
    }

    public CMatrix threshold(int t) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.binarizeGrayScaleImage(ret.array, t);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    public CMatrix threshold(int t1, int t2) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.thresholdGray(ret.image, t1, t2);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);

        return ret;
    }

    public void holdOn() {
        hold_on = true;
    }

    public void holdOff() {
        hold_on = false;
    }

    public int toplaNewApproach(int... a) {
        int t = 0;
        for (int i = 0; i < a.length; i++) {
            t += a[i];
        }
        return t;
    }

    public CPoint getSize() {
        return new CPoint(this.getRowNumber(), this.getColumnNumber());
    }

    public CSize getImageSize() {
        return new CSize(this.getColumnNumber(), this.getRowNumber());
    }

    public CMatrix serialize(String fileName) {
        try {
            FactoryUtils.serialize(this, fileName);
        } catch (IOException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return this;
    }

    public CMatrix deSerialize(String fileName) {
        CMatrix cm = CMatrix.getInstance();
        try {
            cm = (CMatrix) FactoryUtils.deserialize(fileName);
        } catch (IOException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }

        return cm;
    }

    /**
     * Matlab compatible see code of imnoise in Matlab
     *
     * @return
     */
    public CMatrix imnoise() {
        CMatrix ret = this.clone(this);

//        ret.array = FactoryUtils.addGaussianNoise(ret.array, 0, 0.1);
        ret.array = FactoryUtils.addSaltAndPepperNoise(ret.array, 0.1);
        ret.image = ImageProcess.pixelsToImageGray(ret.array);

        return ret;
    }

    /**
     * Matlab compatible see code of imnoise in Matlab
     *
     * @param m
     * @param v
     * @return
     */
    public CMatrix imnoise(double m, double v) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryUtils.addGaussianNoise(ret.array, m, v);
        ret.image = ImageProcess.pixelsToImageGray(ret.array);

        return ret;
    }

    /**
     * split method separates CMatrix into nFolds disjoint subset according to
     * the specified dimension last subset generally greater and equal to the
     * previous subset if number of rows can not be separated equally.
     *
     * split metodu CMatrix matrisini kesişmesi olmayan nFold adet alt kümeye
     * ayırır en son alt kümenin eleman sayısı eğer ki tam bölünemiyorsa
     * genellikle öncekilerden büyük eşittir
     *
     * @param nFolds
     * @return array of CMatrix
     */
    public CMatrix[] split(int nFolds) {
        CMatrix randData = this.clone(this);

        CMatrix[] ret = new CMatrix[nFolds];
        int nRows = randData.getRowNumber();
        int nCols = randData.getColumnNumber();
        int delta = nRows / nFolds;
        for (int i = 0; i < nFolds - 1; i++) {
            ret[i] = randData.cmd(i * delta + ":" + ((i + 1) * delta - 1), ":");//.println((i + 1) + ".subset");
        }
        CMatrix cm = CMatrix.getInstance().zeros(1, nCols);
        for (int i = (nFolds - 1) * delta; i < nRows; i++) {
            CMatrix temp = randData.getRowMatrix(i).transpose();
            cm = cm.cat(2, temp);
        }
        cm = cm.deleteRow(0);
        ret[nFolds - 1] = cm;//.println((nFolds) + ".subset");
        return ret;
    }

    /**
     * splitTestAndTrain method separates CMatrix Test and Train set based on
     * the ntrain and ntest values. ratio ranges between 0 and 1 and takes
     * floating number. 4 , 1 means 0.75 75% is train and 25% is test. It
     * returns CMatrix[0] as train and CMatrix[1] as test sets.
     *
     * splitTestAndTrain komutu parametrede belirtilmiş ntrain ve ntest
     * değerlerinin oranı reel sayı (0..1) arasında değişir. Verisetini test ve
     * train kümesine ayırır. 4 , 1 girilmesi durumunda oran 0.75 olacağından,
     * %75 train için , %25 test için ayırır. Geriye CMatrix[0] train, ve
     * CMatrix[1] ise test set olarak gönderir.
     *
     * @return array of CMatrix
     */
    public CMatrix[] splitTestAndTrain(int ntrain, int ntest) {
        CMatrix ds = this.clone(this);

        CMatrix[] ret = new CMatrix[2];
        double r = 1.0 * ntrain / (ntrain + ntest);
        int pos = (int) (ds.getRowNumber() * r);
        ret[0] = ds.cmd("0:" + pos, ":");
        ret[1] = ds.cmd(pos + ":end", ":");
        return ret;
    }

    /**
     * splitTestAndTrain method separates CMatrix Test and Train set based on
     * the ratio. ratio ranges between 0 and 1 and takes floating number. 0.75
     * means 75% is train and 25% is test. It returns CMatrix[0] as train and
     * CMatrix[1] as test sets.
     *
     * splitTestAndTrain komutu parametrede belirtilmiş reel sayı (0..1)
     * oranında verisetini test ve train kümesine ayırır. 0.75 girilmesi
     * durumunda, %75 train için , %25 test için ayırır. Geriye CMatrix[0]
     * train, ve CMatrix[1] ise test set olarak gönderir.
     *
     * @return array of CMatrix
     */
    public CMatrix[] splitTestAndTrain(double r) {
        CMatrix ds = this.clone(this);

        CMatrix[] ret = new CMatrix[2];
        int pos = (int) (ds.getRowNumber() * r);
        ret[0] = ds.cmd("0:" + pos, ":");
        ret[1] = ds.cmd(pos + ":end", ":");
        return ret;
    }

    /**
     * Exclude operates as setdiff method in Matlab it simply try to get rid off
     * values from the original matrix if matrix size is in accordance based on
     * rows or columns logic
     *
     * please see cvSets or crossValidationSets for further info
     *
     * @param cm
     * @param dimension : 1=exclude from rows, 2=exclude from columns
     * @return
     */
    public CMatrix exclude(CMatrix cm, int dimension) {
        CMatrix ret = this.clone(this);

        if (dimension == 1 && ret.getColumnNumber() != cm.getColumnNumber()) {
            System.out.println("column number must be equal");
            return ret;
        }
        if (dimension == 2 && ret.getRowNumber() != cm.getRowNumber()) {
            System.out.println("row number must be equal");
            return ret;
        }
        if (dimension == 1 && ret.getColumnNumber() == cm.getColumnNumber()) {
            double[][] d = FactoryMatrix.excludeRows(ret.array, cm.array);
            ret.setArray(d);
        }
        if (dimension == 2 && ret.getRowNumber() == cm.getRowNumber()) {
            ret = ret.transpose().exclude(cm.transpose(), 1).transpose();
        }
        return ret;
    }

    /**
     * it splits the dataset into nFolds disjoint folds for test and remaining
     * as train sets. Hence, it holds 2D CMatrix array from which, first
     * dimensions train and second one is test
     *
     * @param nFolds
     * @return
     */
    public CMatrix[][] crossValidationSets(int nFolds) {
        CMatrix randData = this.clone(this);
        CMatrix[][] ret = new CMatrix[nFolds][2];
        int nRows = randData.getRowNumber();
        int nCols = randData.getColumnNumber();
        int delta = nRows / nFolds;
        for (int i = 0; i < nFolds - 1; i++) {
            if (i == 0) {
                ret[i][0] = randData.cmd(((i + 1) * delta) + ":end", ":");
            } else {
                ret[i][0] = randData.cmd("0:" + ((i * delta) - 1), ":").cat(2, randData.cmd(((i + 1) * delta) + ":end", ":"));
            }
            ret[i][1] = randData.cmd(i * delta + ":" + ((i + 1) * delta - 1), ":");//.println((i + 1) + ".subset");
        }
        CMatrix cm = CMatrix.getInstance().zeros(1, nCols);
        for (int i = (nFolds - 1) * delta; i < nRows; i++) {
            CMatrix temp = randData.getRowMatrix(i).transpose();
            cm = cm.cat(2, temp);
        }
        cm = cm.deleteRow(0);
        ret[nFolds - 1][1] = cm;
        ret[nFolds - 1][0] = randData.cmd("0:" + (((nFolds - 1) * delta) - 1), ":");
        return ret;

//        CMatrix cm=this.clone(this); lastCM=ret; 
//        CMatrix[] tests=cm.split(nFolds);
//        CMatrix[][] ret=new CMatrix[nFolds][2];
//        for (int i = 0; i < nFolds; i++) {
//            ret[i][0]=cm.exclude(tests[i], 1);
//            ret[i][1]=tests[i];
//        }
//        return ret;
    }

    public double getMaxTotal() {
        return FactoryUtils.getMaximum(this.array);
    }

    public double getMinTotal() {
        return FactoryUtils.getMinimum(this.array);
    }

    /**
     * converts matrix to 1 dimensional column vector it calls reshape command
     *
     * @return
     */
    public CMatrix toColumnVector() {
        CMatrix ret = this.clone(this);

        ret = ret.reshape(ret.getRowNumber() * ret.getColumnNumber(), 1);
        return ret;
    }

    /**
     * converts matrix to 1 dimensional row vector it calls reshape command
     *
     * @return
     */
    public CMatrix toRowVector() {
        CMatrix ret = this.clone(this);

        ret = ret.reshape(1, ret.getRowNumber() * ret.getColumnNumber());
        return ret;
    }

    public CMatrix jacobianApproximation(CMatrix A, CMatrix b, double tol) {
        CMatrix ret = this.clone(this);

        double error = 0;
        int n = b.getRowNumber();
        double s = 0;
        double xb = 0;
        double w = 1.2;//relaxation number
        double[] x0 = new double[b.getRowNumber()];
        for (int t = 0; t < 2000; t++) {
            error = 0;
            for (int i = 0; i < n; i++) {
                s = 0;
                xb = x0[i];
                for (int j = 0; j < n; j++) {
                    if (i != j) {
                        s = s + A.getValue(i, j) * x0[j];
                    }

                }
                x0[i] = w * (b.toDoubleArray1D()[i] - s) / (A.getValue(i, i)) + (1 - w) * x0[i];
                error += Math.abs(x0[i] - xb);
            }
            if (error / n < tol) {
                break;
            }
        }
        ret.setArray(x0);
        return ret;
    }

    public CMatrix jacobianApproximation(CMatrix b, double tol) {
        CMatrix A = this.clone(this);

        double error = 0;
        int n = b.getRowNumber();
        double s = 0;
        double xb = 0;
        double w = 1.2;//relaxation number
        double[] x0 = new double[b.getRowNumber()];
        for (int t = 0; t < 2000; t++) {
            error = 0;
            for (int i = 0; i < n; i++) {
                s = 0;
                xb = x0[i];
                for (int j = 0; j < n; j++) {
                    if (i != j) {
                        s = s + A.getValue(i, j) * x0[j];
                    }

                }
                x0[i] = w * (b.toDoubleArray1D()[i] - s) / (A.getValue(i, i)) + (1 - w) * x0[i];
                error += Math.abs(x0[i] - xb);
            }
            if (error / n < tol) {
                break;
            }
        }
        CMatrix ret = CMatrix.getInstance(x0);

        return ret;
    }

    /**
     * csvread is similar to the Matlab command and needs only file path of
     * desired excel file
     *
     * @param filePath : excel file path
     * @return CMatrix
     */
    public CMatrix csvread(String filePath) {
        CMatrix ret = this.clone(this);

        ret = CMatrix.getInstance(FactoryUtils.readCSV(filePath, ',', 0));
        return ret;
    }

    public CMatrix csvread(String filePath, char seperator, int header) {
        CMatrix ret = this.clone(this);

        ret = CMatrix.getInstance(FactoryUtils.readCSV(filePath, seperator, header));
        return ret;
    }

    /**
     * check matrix number of rows and columns it should be identical or equal
     * or same
     *
     * @param cm1 : checked matrix
     * @param cm2 : checked matrix
     * @return
     */
    public boolean isIdentical(CMatrix cm1, CMatrix cm2) {
        return cm1.getRowNumber() == cm2.getRowNumber() && cm1.getColumnNumber() == cm2.getColumnNumber();
    }

    /**
     * check matrix number of rows and columns it should be identical or equal
     * or same
     *
     * @param cm : checked matrix
     * @return boolean
     */
    public boolean isIdentical(CMatrix cm) {
        if (this.getRowNumber() == cm.getRowNumber() && this.getColumnNumber() == cm.getColumnNumber()) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Matlab compatible padding around the matrix with value padding amount is
     * determined by nr and nc
     *
     * @param nr: padding number of rows (padding width as vertical)
     * @param nc: padding number of columns (padding width as horizontal)
     * @param val : padding value
     * @return CMatrix
     */
    public CMatrix padarray(int nr, int nc, double val) {
        CMatrix ret = this.clone(this);

        ret = CMatrix.getInstance(FactoryMatrix.padarray(ret.array, nr, nc, val));
        return ret;
    }

    public CMatrix detectFaces(String type) {
        return new CMatrix(ImageProcess.detectFaces(type, this.image));
    }

    public Rectangle[] getFaceLocations(String type) {
        Rectangle[] ret = ImageProcess.getFacesRectangles(type, this.image);
        return ret;
    }

    public CMatrix imupdate() {
        if (image == null || image.getType() == BufferedImage.TYPE_BYTE_GRAY) {
            image = ImageProcess.pixelsToImageGray(array);
        }
        return this;
    }

    public CMatrix updateImage() {
        return imupdate();
    }

    public CMatrix im2bw() {
        CMatrix cm = this.clone(this);

        if (cm.image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            cm = cm.rgb2gray();
        }
        cm = cm.binarizeOtsu();
        return cm;
    }

    public CMatrix im2bw(int thr) {
        CMatrix cm = this.clone(this);

        if (cm.image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            cm = cm.rgb2gray();
        }
        cm = cm.threshold(thr);

        return cm;
    }

    public CMatrix im2bw(int t1, int t2) {
        CMatrix cm = this.clone(this);

        if (cm.image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            cm = cm.rgb2gray();
        }
        cm = cm.imthreshold(t1, t2);

        return cm;
    }

    public CMatrix imbinarizeOtsu() {
        CMatrix cm = this.clone(this);

        if (cm.image.getType() != BufferedImage.TYPE_BYTE_GRAY) {
            cm = cm.rgb2gray();
        }
        cm = cm.binarizeOtsu();

        return cm;
    }

    /**
     * perform image binarization operation by using otsu thresholding
     *
     * @return
     */
    public CMatrix binarizeImage() {
        return im2bw();
    }

    public CMatrix binarizeImage(int thr) {
        return im2bw(thr);
    }

    private CMatrix imthreshold(int t1, int t2) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.adaptiveThreshold(ret.array, t1, t2);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix overlay(CMatrix cm, double alpha) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.overlayImage(ret.image, cm.image, alpha);
        return ret;
    }

    public CMatrix overlay(BufferedImage bf, double alpha) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.overlayImage(ret.image, bf, alpha);
        return ret;
    }

    public CMatrix overlay(CMatrix cm, float alpha, CRectangle cr) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.overlayImage(ret.image, cm.image, cr, 0);
        return ret;
    }

    public CMatrix overlay(CMatrix cm, CPoint cp) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.overlayImage(ret.image, cm.image, cp, 0);
        return ret;
    }

    public CMatrix overlay(BufferedImage bf, CPoint cp) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.overlayImage(ret.image, bf, cp, 0);
        return ret;
    }

    public CMatrix overlay(CMatrix cm, CPoint cp, int backGroundColor) {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.overlayImage(ret.image, cm.image, cp, backGroundColor);
        return ret;
    }

    public CMatrix im_cropBoundingBox() {
        CMatrix ret = this.clone(this);

        ret.image = ImageProcess.cropBoundingBox(ret.image);
        ret.array = ImageProcess.imageToPixelsDouble(ret.image);
        return ret;
    }

    public CMatrix reverseOrder() {
        CMatrix ret = this.clone(this);

        ret.array = FactoryMatrix.reverseOrder(ret.array);
        return ret;
    }

    public CMatrix bitPlaneMSB() {
        CMatrix ret = this.clone(this);

        ret.array = FactoryMatrix.bitPlaneMSB(ret.array);
        return ret;
    }

    public CMatrix bitPlane(int n) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryMatrix.bitPlane(ret.array, n);
        return ret;
    }

    /**
     * for compliance with Matlab, native java developer can use bitPlane
     * command instead
     *
     * @param n
     * @return
     */
    public CMatrix bitget(int n) {
        return bitPlane(n);
    }

    public CMatrix imbitget(int n) {
        return bitPlane(n);
    }

    public CMatrix getImageBitSlicing(int n) {
        return bitPlane(n);
    }

    public CMatrix getBitPlane(int n) {
        return bitPlane(n);
    }

    public CMatrix im2QuantizationLevel(int n) {
        if (n >= 256 || n <= 0) {
            return this;
        }
        double t = 1;
        n = n - 1;
        if (n == 0) {
            t = 255;
        } else {
            t = 255.0 / n;
        }

        CMatrix ret = this.clone(this);

        ret = map(0, n).round().timesScalar(t);
        return ret;
    }

    public CMatrix equalizeHistogramMusa() {
        CMatrix ret = this.clone(this);

        ret = ret.getCDFData().map(0, 255).round();
        double[][] data = this.clone(this).toDoubleArray2D();
        double[] ncdf = ret.toDoubleArray1D();
        int val = 0;
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data[0].length; j++) {
                val = (int) data[i][j];
                data[i][j] = ncdf[val];
            }
        }
        ret.setArray(data);
        ret.setImage(ImageProcess.pixelsToImageGray(data));
        return ret;
    }

    public CMatrix histeq() {
        return equalizeHistogram();
    }

    public CMatrix histeqMusa() {
        return equalizeHistogramMusa();
    }

    public CMatrix equalizeHistogram() {
        CMatrix ret = this.clone(this);

        ret.setImage(ImageProcess.equalizeHistogram(ret.image));
        return ret;
    }

    public CPoint getCenterOfGravity() {
        return ImageProcess.getCenterOfGravityGray(array);
    }

    public CMatrix smoothMatrix() {
        CMatrix ret = this.clone(this);

        ret.array = FactoryMatrix.smoothColumns(ret.array, 3);
        ret.updateImage();
        return ret;
    }

    public CMatrix smoothMatrix(int size) {
        CMatrix ret = this.clone(this);

        ret.array = FactoryMatrix.smoothColumns(ret.array, size);
        ret.updateImage();
        return ret;
    }

    public CMatrix smoothMatrixTimes(int times) {
        CMatrix ret = this.clone(this);

        for (int i = 0; i < times; i++) {
            ret = ret.smoothMatrix();
        }
        return ret;
    }

    /**
     * param N:for N bit i.e:8 bit produces totally 256 LBP features
     */
    public CMatrix lbp1D(int N, boolean isRegular) {
        return getLBP1D(N, isRegular);
    }

    public CMatrix getLBP1D(int N, boolean isRegular) {
        CMatrix ret = this.clone(this);

        int[][] lbp = FeatureExtractionLBP.getLBP(ret.array, N, isRegular);
        ret.setArray(lbp);
        return ret;
    }

    /**
     * Fast Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @return
     */
    public CMatrix fwt_1D_decompose(String type) {
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryMatrix.fwt_1D_decompose(ret.toDoubleArray1D(), type));
        return ret;
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @return
     */
    public CMatrix dwt_1D_decompose(String type) {
        return fwt_1D_decompose(type);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @return
     */
    public CMatrix wavelet_1D_decompose(String type) {
        return fwt_1D_decompose(type);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @return
     */
    public CMatrix transformWavelet_1d_decompose(String type) {
        return fwt_1D_decompose(type);
    }

    /**
     * Fast Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix fwt_forward(String type, int depth) {
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryMatrix.fwt_1D_forward(ret.toDoubleArray1D(), type, depth));
        return ret;
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix dwt_forward(String type, int depth) {
        return fwt_forward(type, depth);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix wavelet_forward(String type, int depth) {
        return fwt_forward(type, depth);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix transformWavelet_forward(String type, int depth) {
        return fwt_forward(type, depth);
    }

    /**
     * Fast Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix fwt_reverse(String type, int depth) {
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryMatrix.fwt_1D_reverse(ret.toDoubleArray1D(), type, depth));
        return ret;
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix dwt_reverse(String type, int depth) {
        return fwt_reverse(type, depth);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix wavelet_reverse(String type, int depth) {
        return fwt_reverse(type, depth);
    }

    /**
     * Discrete Wavelet Transform Implementation
     *
     * @param type : write "haar" or "db2", "db3", "db4", "db5", "db6", "db7" in
     * a samller case
     * @param depth: write decomposition level
     * @return
     */
    public CMatrix transformWavelet_reverse(String type, int depth) {
        return fwt_reverse(type, depth);
    }

    /**
     * link (things) together in a chain or series according to rows
     *
     * @return
     */
    public CMatrix concatenateRows() {
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryMatrix.concatenateRows(ret.array));
        return ret;
    }

    /**
     * link (things) together in a chain or series according to columns
     *
     * @return
     */
    public CMatrix concatenateColumns() {
        CMatrix ret = this.clone(this);

        ret.setArray(FactoryMatrix.concatenateColumns(ret.array));
        return ret;
    }

    public double[][][] getARGB() {
        if (image != null) {
            return ImageProcess.imageToPixelsColorDoubleFaster(image);
        } else {
            this.image = ImageProcess.pixelsToImageColor(array);
            return ImageProcess.imageToPixelsColorDoubleFaster(image);
        }
    }

    public CMatrix argbToBufferedImage(double[][][] argb) {
        return fromARGB(argb);
    }

    public CMatrix fromARGB(double[][][] argb) {
        BufferedImage img = ImageProcess.pixelsToImageColorArgbFormat(argb);
        img = ImageProcess.convertToBufferedImageTypes(img, BufferedImage.TYPE_3BYTE_BGR);
        return new CMatrix(img);
    }

    public CMatrix fromARGB(CMatrix[] cms) {
        double[][][] argb = new double[4][][];
        for (int i = 0; i < cms.length; i++) {
            argb[i] = cms[i].array;
        }
        BufferedImage img = ImageProcess.pixelsToImageColorArgbFormat(argb);
        return new CMatrix(img);
    }

    public CMatrix highPass(CMatrix cm) {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryMatrix.highPass(ret.array, cm.array);
        ret.setArray(d);
        return ret;
    }

    public CMatrix lowPass(CMatrix cm) {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryMatrix.lowPass(ret.array, cm.array);
        ret.setArray(d);
        return ret;
    }

    public CMatrix[] toARGB() {
        long t1 = FactoryUtils.tic();
        CMatrix[] ret = new CMatrix[4];
        double[][][] d = toDoubleArray3D();
        t1 = FactoryUtils.toc("cost of to double array conversion:", t1);
        for (int i = 0; i < ret.length; i++) {
            ret[i] = new CMatrix(d[i]);
        }
        t1 = FactoryUtils.toc("cost of building new CMatrix:", t1);
        return ret;
    }

    /**
     * improved version of plot, based on javafx charts
     *
     * @param lst : column names
     * @return
     */
    public CMatrix setColumnNames(List<String> lst) {
        this.columnNames = lst;
        return this;
    }

    public List<String> getColumnNames() {
        return columnNames;
    }

    public List getClassLabels() {
        return classLabels;
    }

    public CMatrix setClassLabels(List classLabels) {
        this.classLabels = classLabels;
        return this;
    }

    /**
     * wait in milli seconds
     *
     * @param milli_second : milli second
     * @return
     */
    public CMatrix delay(int milli_second) {
        try {
            Thread.sleep(milli_second);
        } catch (InterruptedException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return this;
    }

    public CMatrix setXData4FX(double[] d) {
        this.xData4FX = d;
        return this;
    }

    public double[] getXData4FX() {
        return xData4FX;
    }

    /**
     * sort matrix (column wised) along ascending order similar to the Matlab
     * sort function
     *
     * @return
     */
    public CMatrix sort() {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryMatrix.sort(ret.array, "column", "ascend");
        ret.setArray(d);
        return ret;
    }

    /**
     * sort matrix (column wised) along ascending order similar to the Matlab
     * sort function
     *
     * @param dimension : sorting along which dimension; select "column" or
     * "row"
     * @return
     */
    public CMatrix sort(String dimension) {
        CMatrix ret = this.clone(this);

        double[][] d = FactoryMatrix.sort(ret.array, dimension, "ascend");
        ret.setArray(d);
        return ret;
    }

    /**
     * sort matrix dimension wised selected order similar to the Matlab please
     * choose appropriate String keywords below as it is. sort function
     *
     * @param dimension : sorting along which dimension; select "column" or
     * "row"
     * @param order : in an "ascend" or "descend" order select one of both
     * @return
     */
    public CMatrix sort(String dimension, String order) {
        CMatrix ret = this.clone(this);
        double[][] d = FactoryMatrix.sort(ret.array, dimension, order);
        ret.setArray(d);
        return ret;
    }

    public CMatrix catHorizontal(int dim, int... val) {
        CMatrix ret = this.clone(this);
        double[][] d = FactoryMatrix.catHorizontal(ret.array, val);
        ret.setArray(d);
        return ret;
    }

    public CMatrix catVertical(int dim, int... val) {
        CMatrix ret = this.clone(this);
        double[][] d = FactoryMatrix.catVertical(ret.array, val);
        ret.setArray(d);
        return ret;
    }

    public CMatrix imerode() {
        CMatrix ret = this.clone(this);
        ret.setImage(ImageProcess.erode(ret.getImage()));
        return ret;
    }

    public CMatrix imdilate() {
        CMatrix ret = this.clone(this);
        ret.setImage(ImageProcess.dilate(ret.getImage()));
        return ret;
    }

    /**
     * Calculate Euclidean distance between two vectors
     *
     * @param cm
     * @return
     */
    public CMatrix euc(CMatrix cm) {
        if (!this.isIdentical(cm)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = this.clone(this);
        ret = ret.minus(cm).pow(2).sum().sqrt();
        return ret;
    }

    /**
     * Calculate Euclidean distance between two vectors
     *
     * @param cm1
     * @param cm2
     * @return
     */
    public CMatrix euc(CMatrix cm1, CMatrix cm2) {
        if (!cm1.isIdentical(cm2)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = cm1.minus(cm2).pow(2).sum().sqrt();
        return ret;
    }

    /**
     * Calculate column based Mean Square Error of two Matrices
     *
     * @param cm
     * @return
     */
    public CMatrix mse(CMatrix cm) {
        if (!this.isIdentical(cm)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = this.clone(this);
        ret = ret.minus(cm).pow(2).sum().sum();
        return ret;
    }

    /**
     * Calculate column based Mean Square Error of two Matrices
     *
     * @param cm1
     * @param cm2
     * @return
     */
    public CMatrix mse(CMatrix cm1, CMatrix cm2) {
        if (!cm1.isIdentical(cm2)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = cm1.minus(cm2).pow(2).sum().sum();
        return ret;
    }

    /**
     * Calculate column based Mean Square Error of two Matrices
     *
     * @param cm
     * @return
     */
    public CMatrix getMeanSquareError(CMatrix cm) {
        return mse(cm);
    }

    /**
     * Calculate column based Mean Square Error of two Matrices
     *
     * @param cm1
     * @param cm2
     * @return
     */
    public CMatrix getMeanSquareError(CMatrix cm1, CMatrix cm2) {
        return mse(cm1, cm2);
    }

    /**
     * Calculates column based Cosine Similarity between two matrix
     *
     * @param cm
     * @return
     */
    public CMatrix cosineSimilarity(CMatrix cm) {
        if (!this.isIdentical(cm)) {
            System.err.println("Matrix dimension is not identical");
            return this;
        }
        CMatrix ret = this.clone(this);
        double[] d = FactoryUtils.getCosineSimilarity(ret.transpose().array, cm.transpose().array);
        ret.setArray(d);
        return ret;
    }

    /**
     * Replicate/Duplicate the Matrix n times along column
     *
     * @param cm: replicated matrix
     * @param n : n times
     * @return CMatrix
     */
    public CMatrix replicateColumn(CMatrix cm, int n) {
        CMatrix ret2 = cm.clone(this);
        for (int i = 0; i < n - 1; i++) {
            cm = cm.cat(1, ret2);
        }
        return cm;
    }

    /**
     * Replicate/Duplicate the Matrix n times along column
     *
     * @param n
     * @return
     */
    public CMatrix replicateColumn(int n) {
        CMatrix ret = this.clone(this);
        CMatrix ret2 = this.clone(this);
        for (int i = 0; i < n - 1; i++) {
            ret = ret.cat(1, ret2);
        }
        return ret;
    }

    /**
     * Replicate/Duplicate the Matrix n times along column
     *
     * @param n
     * @return
     */
    public CMatrix duplicateColumn(int n) {
        return replicateColumn(n);
    }

    /**
     * Replicate/Duplicate the Matrix n times along row
     *
     * @param cm: replicated matrix
     * @param n : n times
     * @return CMatrix
     */
    public CMatrix replicateRow(CMatrix cm, int n) {
        CMatrix ret2 = cm.clone(this);
        for (int i = 0; i < n - 1; i++) {
            cm = cm.cat(2, ret2);
        }
        return cm;
    }

    /**
     * Replicate/Duplicate the Matrix n times along row
     *
     * @param n
     * @return
     */
    public CMatrix replicateRow(int n) {
        CMatrix ret = this.clone(this);
        CMatrix ret2 = this.clone(this);
        for (int i = 0; i < n - 1; i++) {
            ret = ret.cat(2, ret2);
        }
        return ret;
    }

    /**
     * Replicate/Duplicate the Matrix n times along row
     *
     * @param n
     * @return
     */
    public CMatrix duplicateRow(int n) {
        return replicateRow(n);
    }

    /**
     * similar to python make_blobs generate data set with a number of centers
     * of Gaussian distribution based on given n_samples and
     * n_features(dimension) class labels (centers) can be accessed via
     * getClassLabel method columns are n_features rows are n_samples hint: you
     * can best visualize the dataset by using scatter method
     *
     * @param n_samples
     * @param n_features
     * @param centers
     * @return
     */
    public CMatrix make_blobs(int n_samples, int n_features, int centers) {
        return make_blobs(n_samples, n_features, centers, 100, 5);
    }

    public List getClassLabelValues() {
        return classLabelValues;
    }

    public CMatrix setClassLabelValues(List classLabels) {
        this.classLabelValues = classLabels;
        return this;
    }

    public List getClassLabelNames() {
        return classLabelNames;
    }

    public CMatrix setClassLabelNames(List classLabelNames) {
        this.classLabelNames = classLabelNames;
        return this;
    }

    /**
     * similar to python; make_blobs generate data set with a number of centers
     * of Gaussian distribution based on given n_samples and
     * n_features(dimension) class labels (centers) can be accessed via
     * getClassLabel method columns are n_features rows are n_samples hint: you
     * can best visualize the dataset by using scatter method
     *
     * @param n_samples
     * @param n_features
     * @param n_groups
     * @param mean_scale
     * @param var_scale
     * @return
     */
    public CMatrix make_blobs(int n_samples, int n_features, int n_groups, int mean_scale, int var_scale) {
        float[][] f = FactoryMatrix.make_blobs(n_samples, n_features, n_groups, mean_scale, var_scale, random);
        setArray(f);
        float[] cl = FactoryMatrix.getLastColumn(f);
        setClassLabelValues(Arrays.asList(cl));
        String[] gr_names = new String[n_groups];
        for (int i = 0; i < n_groups; i++) {
            gr_names[0] = "group " + (i + 1);
        }
        setClassLabelNames(Arrays.asList(gr_names));
        return this;
    }

    public CMatrix setArray(float[][] f) {
        array = FactoryUtils.toDoubleArray2D(f);
        return this;
    }

    /**
     * set SecureRandom seed in order to guarantee the same results for each
     * draw
     *
     * @param n
     * @return
     */
    public CMatrix random_seed(int n) {
        random = new SecureRandom();
        random.setSeed(n);
        return this;
    }

    /**
     * set SecureRandom seed in order to guarantee the same results for each
     * draw
     *
     * @param n
     * @return
     */
    public CMatrix random_seed(Object n) {
        random = new SecureRandom();
        return this;
    }

    /**
     * set SecureRandom seed in order to guarantee the same results for each
     * draw
     *
     * @param n
     * @return
     */
    public CMatrix setRandomSeed(int n) {
        return random_seed(n);
    }

    /**
     * set SecureRandom seed in order to guarantee the same results for each
     * draw
     *
     * @param n
     * @return
     */
    public CMatrix setRandomSeed(Object n) {
        return random_seed(n);
    }

    /**
     * select n random sample from the matrix mxn, if mxn is normal matrix it
     * selects random n rows, if mxn is column vector it selects random n rows,
     * if mxn is row vector it selects random n column
     *
     * @param n
     * @return
     */
    public CMatrix random_sample(int n) {
        CMatrix ret = this.clone(this);
        int nr = ret.getRowNumber();
        int nc = ret.getColumnNumber();
        int[] index = FactoryMatrix.rand(n, nr, random);
        if (nr > 1 && nc >= 1) {
            double[][] d = new double[n][nc];
            for (int i = 0; i < n; i++) {
                d[i] = ret.array[index[i]];
            }
            ret = ret.setArray(d);
        } else if (nr == 1) {
            double[] d = new double[n];
            double[] ref = ret.toDoubleArray1D();
            for (int i = 0; i < n; i++) {
                d[i] = ref[index[i]];
            }
            ret = ret.setArray(d);
        }
        return ret;
    }

    /**
     * generate a kernel of Laplacian of Gaussian so called Mexican Hat as 2D
     * LoG(x,y) = [(x^2+y^2-2*Sig^2)/Sig^4]*e^(-(x^2+y^2)/(2*Sig^2))
     *
     * @param sigma : standard deviation
     * @return CMatrix
     */
    public CMatrix mexicanHat2D(double sigma) {
        CMatrix ret = this.clone(this);
        int nr = ret.getRowNumber();
        int nc = ret.getColumnNumber();
        int mid = nr / 2;
        CMatrix cmx = CMatrix.getInstance().linspace(-mid, mid, nr).replicateColumn(nc).transpose();//.dump();
        CMatrix cmy = cmx.transpose();//.dump();
        double std2 = sigma * sigma;
        double std4 = std2 * std2;
        CMatrix arg = cmx.multiplyElement(cmx).add(cmy.multiplyElement(cmy)).multiplyScalar(-1).divideScalar(2 * std2);
        CMatrix h = arg.exp();
        double sumh = h.sumTotal();
        if (sumh != 0) {
            h = h.divideScalar(sumh);
        }
        CMatrix arg2 = cmx.multiplyElement(cmx).add(cmy.multiplyElement(cmy)).minusScalar(2 * std2).divideScalar(std4);
        CMatrix h1 = h.multiplyElement(arg2);
        h = h1.minusScalar(h1.sumTotal() / (ret.getMatrixVolume()));

        return h;
    }

    public CMatrix mexicanHat1D(double sigma) {
        CMatrix ret = this.clone(this);
        ret = ret.pow(2).timesScalar(-0.5).exp().multiplyElement(ret.pow(2).timesScalar(sigma).minusFromScalar(1)).timesScalar(2.0 / (Math.sqrt(3) * Math.pow(Math.PI, 0.25)));
        return ret;
    }

    public double getMatrixVolume() {
        return this.getRowNumber() * this.getColumnNumber();
    }

    /**
     * generate mesh grid matrix along x axes it is used for applying 2D
     * functions on the plane in a loop-less manner resembles to the Matlab
     * meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @return CMatrix
     */
    public CMatrix meshGridX(double from, double to) {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.meshGridX(ret.array, from, to);
        return ret;
    }

    /**
     * generate mesh grid matrix along x axes in default it is used for applying
     * 2D functions on the plane in a loop-less manner resembles to the Matlab
     * meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @return CMatrix
     */
    public CMatrix meshGrid(double from, double to) {
        return meshGridX(from, to);
    }

    /**
     * generate mesh grid matrix along x axes yields square matrix of numberOf x
     * numberOf it is used for applying 2D functions on the plane in a loop-less
     * manner resembles to the Matlab meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @param numberOf:# of elements
     * @return CMatrix
     */
    public CMatrix meshGridX(double from, double to, int numberOf) {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.meshGridX(from, to, numberOf);
        return ret;
    }

    /**
     * generate mesh grid matrix along x axes in default yields square matrix of
     * numberOf x numberOf it is used for applying 2D functions on the plane in
     * a loop-less manner resembles to the Matlab meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @param numberOf:# of elements
     * @return CMatrix
     */
    public CMatrix meshGrid(double from, double to, int numberOf) {
        return meshGridX(from, to, numberOf);
    }

    /**
     * generate mesh grid matrix along y axes it is used for applying 2D
     * functions on the plane in a loop-less manner resembles to the Matlab
     * meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @return CMatrix
     */
    public CMatrix meshGridY(double from, double to) {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.meshGridY(ret.array, from, to);
        return ret;
    }

    /**
     * generate mesh grid matrix along y axes yields square matrix of numberOf x
     * numberOf it is used for applying 2D functions on the plane in a loop-less
     * manner resembles to the Matlab meshgrid command
     *
     * @param from:initial point
     * @param to:end point
     * @param numberOf:# of elements
     * @return CMatrix
     */
    public CMatrix meshGridY(double from, double to, int numberOf) {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.meshGridY(from, to, numberOf);
        return ret;
    }

    public CMatrix meshGridIterateForward() {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.meshGridIterateForward(ret.array);
        return ret;
    }

    public CMatrix inverseLog() {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.inverseLog(ret.array);
        return ret;
    }

    public CMatrix inversePower(double x) {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.inversePower(x, ret.array);
        return ret;
    }

    public CMatrix powerByScalar(double x) {
        return inversePower(x);
    }

    public CMatrix imWeightCenter(boolean isShow) {
        CMatrix ret = this.clone(this);
        CPoint cp = ImageProcess.getCenterOfGravityColor(ret.image, isShow);
        double[] d = new double[2];
        d[0] = cp.row;
        d[1] = cp.column;
        ret.setArray(d);
        return ret;
    }

    public CMatrix applyFunction(CMatrix f) {
        CMatrix ret = this.clone(this);
        ret = ret.rgb2gray();
        ret.array = FactoryMatrix.applyFunction(ret.array, f.toDoubleArray1D());
        ret.image = ImageProcess.pixelsToImageGray(ret.array);
        return ret;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix as
     * cells from blue to red in default or user can give the color range or
     * user can specify the center point (value) in the matrix and remaining
     * cells are colored around this point
     *
     * @return
     */
    public CMatrix heatmap() {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix as
     * cells from blue to red in default or user can give the color range or
     * user can specify the center point (value) in the matrix and remaining
     * cells are colored around this point
     *
     * @param showValue : write the value of the cell et the center
     * @return
     */
    public CMatrix heatmap(boolean showValue) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix
     * around the center color
     *
     * @param centerColor cells are colored around this color
     * @return original CMatrix
     */
    public CMatrix heatmap(Color centerColor) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix
     * around center color
     *
     * @param centerColor cells are colored around this color
     * @param width :width of the frame
     * @param height:height of the frame
     * @return original CMatrix
     */
    public CMatrix heatmap(Color centerColor, int width, int height) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this, width, height);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this, width, height);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix
     * around center color
     *
     * @param centerColor cells are colored around this color
     * @param width :width of the frame
     * @param height:height of the frame
     * @param showCellEdge : cell's edge visible or not
     * @return original CMatrix
     */
    public CMatrix heatmap(Color centerColor, int width, int height, boolean showCellEdge) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this, width, height, showCellEdge);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this, width, height, showCellEdge);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix
     * around center color
     *
     * @param centerColor cells are colored around this color
     * @param width :width of the frame
     * @param height:height of the frame
     * @param showCellEdge : cell's edge visible or not
     * @return original CMatrix
     */
    public CMatrix heatmap(Color centerColor, int width, int height, boolean showCellEdge, boolean showValue) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this, width, height, showCellEdge, showValue);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this, width, height, showCellEdge, showValue);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    /**
     * compatible with Matlab's heatmap function try to colorize the matrix as
     * cells from blue to red in default or user can give the color range or
     * user can specify the center point (value) in the matrix and remaining
     * cells are colored around this point
     *
     * @param fromColor start color
     * @param centerColor center color
     * @param toColor final color
     * @return
     */
    public CMatrix heatmap(Color fromColor, Color centerColor, Color toColor) {
        if (!hold_on) {
            frameHeatMap = new FrameHeatMap(this);
        } else {
            if (frameHeatMap == null) {
                frameHeatMap = new FrameHeatMap(this);
            }
            frameHeatMap.setMatrix(this);
        }
        frameHeatMap.setFromColor(fromColor);
        frameHeatMap.setCenterColor(centerColor);
        frameHeatMap.setToColor(toColor);
        frameHeatMap.setVisible(true);
        return this;
    }

    public CMatrix addClassLabel(String scl) {
        CMatrix ret = this.clone(this);
        double cl = Double.parseDouble(scl);
        ret.setArray(FactoryMatrix.addClassLabel(ret.array, cl));
        return ret;
    }

    /**
     * perlin noise generator with scale equals to 0.1 by default
     *
     * @return
     */
    public CMatrix perlinNoise() {
        CMatrix ret = this.clone(this);
        ret.setArray(FactoryMatrix.perlinNoise(ret.array));
        ret.name = this.name + "|perlinNoise";
        return ret;
    }

    /**
     * perlin noise generator with scale 0.01 to 10
     *
     * @param scale 0.01 to 10 hint: you should decrease scale if your matrix
     * become larger
     * @return
     */
    public CMatrix perlinNoise(double scale) {
        CMatrix ret = this.clone(this);
        ret.setArray(FactoryMatrix.perlinNoise(ret.array, scale));
        ret.name = this.name + "|perlinNoise";
        return ret;
    }

    /**
     * Convolution operation
     *
     * @param kernel : kernel should be smaller than the original matrix
     * @return cloned CMatrix object
     */
    public CMatrix convolve(CMatrix kernel) {
        if (kernel.getRowNumber() != kernel.getColumnNumber()
                || kernel.getRowNumber() % 2 == 0
                || kernel.getColumnNumber() % 2 == 0
                || kernel.getRowNumber() >= this.getRowNumber()
                || kernel.getColumnNumber() >= this.getColumnNumber()) {
            System.err.println("kernel mismatch");
            return this;
        }
        CMatrix ret = this.clone(this);
        ret.name = this.name + "|convolve";
        ret.setArray(FactoryMatrix.convolve(ret.array, kernel.array));
        return ret;
    }

//    public CDL switchToDeepLearning() {
//        return CDL.getInstance(this);
//    }

    public CMatrix distinct() {
        CMatrix ret = this.clone(this);
        double[] d = ret.toDoubleArray1D();
        d = Arrays.stream(d).distinct().toArray();
        ret.setArray(d);
        return ret;
    }

    public CMatrix bruteForceAttack(char[] pool, String pass, boolean isPrint) {
        long t = FactoryUtils.tic();
        BruteForce bf = new BruteForce(pool, 1);
        String newPass = bf.toString();
        while (true) {
            if (newPass.equals(pass)) {
                System.out.println("Password Found: " + newPass);
                break;
            }
            newPass = bf.toString();
            if (isPrint) {
                System.out.println("" + newPass);
            }
            bf.increment();
        }
        FactoryUtils.toc(t);
        return this;
    }

    public CMatrix shufflePixelImage() {
        CMatrix ret = this.clone(this);
        int[] indexes = new int[ret.array.length * ret.array[0].length];
        ret.array = FactoryMatrix.shuffleRowsAndColumns(ret.array, indexes);
        ret.shuffleIndexes = indexes;
        return ret;
    }

    public CMatrix deShufllePixelImage() {
        CMatrix ret = this.clone(this);
        ret.array = FactoryMatrix.deShuffleRowsAndColumns(ret.array, ret.shuffleIndexes);
        return ret;
    }

    /**
     * produce diagonal matrix based on the sequence provided in parameter i.e:
     * n=5 means 0:5 --> 0,1,2,3,4
     *
     * @param n
     * @return
     */
    public CMatrix diag(int n) {
        CMatrix ret = range(0, n).replicateColumn(n).multiplyElement(CMatrix.getInstance().eye(n));
        return ret;
    }

    /**
     * produce diagonal matrix based on the sequence provided as String command
     * ie: "-12:15:1.44"
     *
     * @param s
     * @return
     */
    public CMatrix diag(String s) {
        if (!s.contains(":")) {
            System.out.println("command should contain : range");
            return this;
        }
        double[] p = FactoryUtils.resolveParamForRange(s);
        CMatrix ret = range(p).replicateColumn(p.length).multiplyElement(CMatrix.getInstance().eye(p.length));
        return ret;
    }

    /**
     * produce diagonal matrix based on the sequence provided as 1D array
     *
     * @param p
     * @return
     */
    public CMatrix diag(double[] p) {
        CMatrix ret = range(p).replicateColumn(p.length).multiplyElement(CMatrix.getInstance().eye(p.length));
        return ret;
    }

    /**
     * give info about current matrix size (number of rows;number of columns)
     *
     * @return
     */
    public CMatrix shape() {
        System.out.println("Matrix Shape:[" + this.getRowNumber() + "," + this.getColumnNumber() + "]");
        return this;
    }

    /**
     * give info about given matrix size (number of rows;number of columns)
     *
     * @param cm
     * @return
     */
    public CMatrix shape(CMatrix cm) {
        System.out.println("Matrix Shape:[" + cm.getRowNumber() + "," + cm.getColumnNumber() + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(byte[][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(short[][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(int[][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(float[][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(double[][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(String[][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(boolean[][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(byte[][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(short[][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(int[][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(float[][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(double[][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(String[][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(boolean[][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(byte[][][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "," + m[0][0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(short[][][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "," + m[0][0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(int[][][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "," + m[0][0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(float[][][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "," + m[0][0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(double[][][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "," + m[0][0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(String[][][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "," + m[0][0][0].length + "]");
        return this;
    }

    /**
     * tensor information of given n-dim matrix
     *
     * @param m
     * @return
     */
    public CMatrix shape(boolean[][][][] m) {
        System.out.println("Matrix Shape:[" + m.length + "," + m[0].length + "," + m[0][0].length + "," + m[0][0][0].length + "]");
        return this;
    }

    /**
     * is given matrix is Vector or not
     *
     * @param cm
     * @return
     */
    public boolean isVector(CMatrix cm) {
        if (cm.getRowNumber() == 1 || cm.getColumnNumber() == 1) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * is current matrix is Vector or not
     *
     * @param cm
     * @return
     */
    public boolean isVector() {
        if (this.getRowNumber() == 1 || this.getColumnNumber() == 1) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * produce diagonal matrix provided that given matrix is vector of range
     *
     * @param cm
     * @return
     */
    public CMatrix diag(CMatrix cm) {
        if (!cm.isVector(cm)) {
            System.out.println("input is not a vector or nx1 or 1xn matrix");
            return this;
        }
        double[] p = cm.toDoubleArray1D();
        CMatrix ret = range(p).replicateColumn(p.length).multiplyElement(CMatrix.getInstance().eye(p.length));
        return ret;
    }

    /**
     * negate all elements of the current matrix
     *
     * @return
     */
    public CMatrix negate() {
        return this.multiplyScalar(-1);
    }

    /**
     * negate all given indices in the current matrix.
     *
     * @param indices
     * @return
     */
    public CMatrix negate(CMatrix indices) {
        CMatrix ret = this.clone(this);
        double[][] d = FactoryMatrix.clone(ret.array);
        double[] index = indices.toDoubleArray1D();
        double[] d2 = FactoryUtils.toDoubleArray1D(d);
        for (int i = 0; i < index.length; i++) {
            d2[(int) index[i]] = -d2[(int) index[i]];
        }
        ret.setArray(d2).reshape(d.length, d[0].length);
        return ret;
    }

    /**
     * negate all given indices in the given matrix.
     *
     * @param indices
     * @return
     */
    public CMatrix negate(CMatrix cm, CMatrix indices) {
        CMatrix ret = cm.clone(cm);
        double[][] d = FactoryMatrix.clone(ret.array);
        double[] index = indices.toDoubleArray1D();
        double[] d2 = FactoryUtils.toDoubleArray1D(d);
        for (int i = 0; i < index.length; i++) {
            d2[(int) index[i]] = -d2[(int) index[i]];
        }
        ret.setArray(d2).reshape(d.length, d[0].length);
        return ret;
    }

    /**
     * truncate all the elements of the current matrix from double to integer
     *
     * @return
     */
    public CMatrix trunc() {
        CMatrix ret = this.clone(this);
        double[][] d = ret.array;
        int[][] d2 = FactoryUtils.trunc(d);
        ret.setArray(d2);
        return ret;
    }

    /**
     * truncate all the elements of the given matrix from double to integer
     *
     * @param cm
     * @return
     */
    public CMatrix trunc(CMatrix cm) {
        CMatrix ret = cm.clone(cm);
        double[][] d = ret.array;
        int[][] d2 = FactoryUtils.toIntArray2D(d);
        ret.setArray(d2);
        return ret;
    }

    /**
     * apply Math.ceil to the all elements of the current matrix
     *
     * @return
     */
    public CMatrix ceil() {
        CMatrix ret = this.clone(this);
        double[][] d = ret.array;
        int[][] d2 = FactoryMatrix.ceil(d);
        ret.setArray(d2);
        return ret;
    }

    /**
     * apply Math.ceil to the all elements of the given matrix
     *
     * @param cm
     * @return
     */
    public CMatrix ceil(CMatrix cm) {
        CMatrix ret = cm.clone(cm);
        double[][] d = ret.array;
        int[][] d2 = FactoryMatrix.ceil(d);
        ret.setArray(d2);
        return ret;
    }

    /**
     * apply Math.floor to the all elements of the current matrix
     *
     * @return
     */
    public CMatrix floor() {
        CMatrix ret = this.clone(this);
        double[][] d = ret.array;
        int[][] d2 = FactoryMatrix.floor(d);
        ret.setArray(d2);
        return ret;
    }

    /**
     * apply Math.ceil to the all elements of the given matrix
     *
     * @param cm
     * @return
     */
    public CMatrix floor(CMatrix cm) {
        CMatrix ret = cm.clone(cm);
        double[][] d = ret.array;
        int[][] d2 = FactoryMatrix.floor(d);
        ret.setArray(d2);
        return ret;
    }

    public CMatrix startWebSocket(InterfaceCallBack icb) {
        FactorySocket.startJavaWebSocketServer(icb);
        return this;
    }

    public CMatrix startWebSocket(int port, InterfaceCallBack icb) {
        FactorySocket.startJavaWebSocketServer(FactoryUtils.getLocalIP(), 8887, icb);
        return this;
    }

    public CMatrix startWebSocket(String ip, int port, InterfaceCallBack icb) {
        FactorySocket.startJavaWebSocketServer(ip, port, icb);
        return this;
    }

    Connection db_con = null;

    public CMatrix connectDB(String dbName, String dbUser, String password) {
        db_con = new FactoryDataBase().connectDB("127.0.0.1", dbName, dbUser, password);
        if (db_con != null) {
            System.out.println("Database connection was established successfully");
        }
        return this;
    }

    public CMatrix connectDB(String ip, String dbName, String dbUser, String password) {
        db_con = new FactoryDataBase().connectDB(ip, dbName, dbUser, password);
        if (db_con != null) {
            System.out.println("Database connection was established successfully");
        }
        return this;
    }

    public CMatrix closeDB() {
        if (db_con != null) {
            try {
                db_con.close();
            } catch (SQLException ex) {
                Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return this;
    }

    public CMatrix executeSQL(String sql, CallBackDataBase callBackDataBase) {
        if (db_con == null) {
            System.out.println("Database connection was crushed try to connect database first");
            return this;
        }
        FactoryDataBase.getResultSet(sql, callBackDataBase);
        return this;
    }

    public String currentDirectory() {
        return FactoryUtils.getDefaultDirectory();
    }

//    public CMatrix setModelForInference(String modelPath, int NUM_CHANNEL, int IMAGE_WIDTH, int IMAGE_HEIGHT, int blockType) {
//        this.NUM_CHANNEL = NUM_CHANNEL;
//        this.IMAGE_WIDTH = IMAGE_WIDTH;
//        this.IMAGE_HEIGHT = IMAGE_HEIGHT;
//        model = FactoryDJL.getModelForInference(modelPath, NUM_CHANNEL, IMAGE_WIDTH, IMAGE_HEIGHT, blockType);
//        translator = ImageClassificationTranslator.builder()
//                .addTransform(new Resize(IMAGE_WIDTH, IMAGE_HEIGHT))
//                .addTransform(new ToTensor())
//                .optApplySoftmax(true)
//                .build();
//        predictor = model.newPredictor(translator);
//        return this;
//    }

    public CMatrix setModelForInference(String modelPath) {
        String base_dir = new File(modelPath).getParent();
        String[] rows = FactoryUtils.readFile(base_dir + "/model_info.txt").split("\n");
        this.NUM_CHANNEL = Integer.parseInt(rows[0].split("=")[1]);
        this.IMAGE_WIDTH = Integer.parseInt(rows[1].split("=")[1]);
        this.IMAGE_HEIGHT = Integer.parseInt(rows[2].split("=")[1]);
        this.NUM_OUTPUT = Integer.parseInt(rows[3].split("=")[1]);
        this.BLOCK_TYPE = Integer.parseInt(rows[4].split("=")[1]);
        if (BLOCK_TYPE == TBlockType.MLP) {
            String s = rows[5].split("=")[1].replace("[", "").replace("]", "").trim();
            String[] ss = s.split(",");
            int n = ss.length;
            int[] hidden = new int[n];
            for (int i = 0; i < n; i++) {
                hidden[i] = Integer.parseInt(ss[i].trim());
            }
            Block block = FactoryDJL.getMLPBlock(NUM_CHANNEL, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_OUTPUT, hidden);
            model = FactoryDJL.getModelForInference(modelPath, block);
        }else if(BLOCK_TYPE == TBlockType.ResNetV50){
            String s = rows[6].split("=")[1];
            int n=Integer.parseInt(s);
            Block block = FactoryDJL.getResNetBlock(NUM_CHANNEL, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_OUTPUT, n);
            model = FactoryDJL.getModelForInference(modelPath, block);
        }

        translator = ImageClassificationTranslator.builder()
                .addTransform(new Resize(IMAGE_WIDTH, IMAGE_HEIGHT))
                .addTransform(new ToTensor())
                .optApplySoftmax(true)
                .build();
        predictor = model.newPredictor(translator);
        return this;
    }

//    public CMatrix setModelForTrain(String modelName, int NUM_CHANNEL, int IMAGE_WIDTH, int IMAGE_HEIGHT, int NUM_OUTPUT, int blockType) {
//        this.NUM_CHANNEL = NUM_CHANNEL;
//        this.IMAGE_WIDTH = IMAGE_WIDTH;
//        this.IMAGE_HEIGHT = IMAGE_HEIGHT;
//        this.NUM_OUTPUT = NUM_OUTPUT;
//        this.BLOCK_TYPE = blockType;
//        this.BLOCK = null;
//        this.MODEL_NAME = modelName;
//        model = FactoryDJL.getModelForTraining(modelName, NUM_CHANNEL, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_OUTPUT, blockType);
//        return this;
//    }
    public CMatrix setModelForTrain(String modelName, int NUM_CHANNEL, int IMAGE_WIDTH, int IMAGE_HEIGHT, int NUM_OUTPUT, int block_type, Block block) {
        this.NUM_CHANNEL = NUM_CHANNEL;
        this.IMAGE_WIDTH = IMAGE_WIDTH;
        this.IMAGE_HEIGHT = IMAGE_HEIGHT;
        this.NUM_OUTPUT = NUM_OUTPUT;
        this.BLOCK_TYPE = block_type;
        this.BLOCK = block;
        this.MODEL_NAME = modelName;
        System.out.println(block.getParameters().get(2).getValue().getName());
        model = FactoryDJL.getModelForTraining(modelName, block);
        return this;
    }

    public String predictWithProbabilities() {
        Image img = ImageFactory.getInstance().fromImage(this.image);
        Classifications predictResult = null;
        try {
            predictResult = predictor.predict(img);
        } catch (TranslateException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return predictResult.toString();
    }

    public String predictWithLabel() {
        Image img = ImageFactory.getInstance().fromImage(this.image);
        Classifications predictResult = null;
        try {
            predictResult = predictor.predict(img);
        } catch (TranslateException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        String predictedLabel = predictResult.topK(1).toString().split(",")[0].split(":")[1].replace('"', ' ').trim();
        return predictedLabel;
    }

    public CMatrix trainDataSet(String trainDSDir, int BATCH_SIZE, int trainRatio, int valRatio, int EPOCHS) {
        ImageFolder dataset = FactoryDJL.initDataset(trainDSDir, BATCH_SIZE,IMAGE_WIDTH,IMAGE_HEIGHT);
        try {
            RandomAccessDataset[] datasets = dataset.randomSplit(trainRatio, valRatio);
            Loss loss = Loss.softmaxCrossEntropyLoss();
            TrainingConfig config = FactoryDJL.setupTrainingConfig(loss);
            Trainer trainer = model.newTrainer(config);
            trainer.setMetrics(new Metrics());
            Shape inputShape = new Shape(1, this.NUM_CHANNEL, this.IMAGE_WIDTH, this.IMAGE_HEIGHT);
            trainer.initialize(inputShape);
            EasyTrain.fit(trainer, EPOCHS, datasets[0], datasets[1]);
            TrainingResult result = trainer.getTrainingResult();
            model.setProperty("Epoch", String.valueOf(EPOCHS));
            model.setProperty("Accuracy", String.format("%.5f", result.getValidateEvaluation("Accuracy")));
            model.setProperty("Loss", String.format("%.5f", result.getValidateLoss()));
            String path = "models/" + model.getName();
            FactoryUtils.makeDirectory(path);
            Path modelDir = Paths.get(path);
            model.save(modelDir, MODEL_NAME);
            FactoryDJL.saveSynset(modelDir, dataset.getSynset());
            TDJLModel model_info = null;
            model_info = new TDJLModel(NUM_CHANNEL, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_OUTPUT, BLOCK_TYPE, BLOCK);
            FactoryDJL.saveModelParam(path + "/model_info.txt", model_info);

        } catch (IOException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (TranslateException ex) {
            Logger.getLogger(CMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return this;
    }

    public CMatrix refresh() {
        System.gc();
        return new CMatrix();
    }

    public CMatrix clear() {
        return refresh();
    }
    
    public CMatrix clean() {
        return refresh();
    }

}
