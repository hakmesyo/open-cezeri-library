/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package cezeri.deep_learning_rest.core;

import cezeri.deep_learning_rest.enums.EnumDataSource;
import cezeri.deep_learning_rest.enums.EnumLearningMode;
import cezeri.deep_learning_rest.interfaces.InterfaceConfiguration;
import cezeri.deep_learning_rest.interfaces.InterfaceDeepLearning;
import cezeri.factory.FactoryUtils;
import java.io.File;


/**
 *
 * @author DELL LAB
 */
public class JDL_Python implements InterfaceDeepLearning {

    private final String strImportLibrary
            = "#Temporary Script generated by Jazari Deep Learning Framework\n"
            + "import tensorflow.keras\n"
            + "from PIL import Image\n"
            + "import numpy as np\n"
            + "import os\n"
            + "import matplotlib.pyplot as plt\n"
            + "from keras.optimizers import Adam,Adadelta\n"
            + "import timeit\n"
            + "import time\n"
            + "import websocket\n"
            + "import cv2\n"
            + "import ctypes\n"
            + "from websocket_server import WebsocketServer\n"
            + "os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'\n"
            + "data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32)\n";
    
    private final String strConnectWebSocket=""
            + "ws=websocket.WebSocket();\n"
            + "ws.connect('ws://127.0.0.1:8887')\n";
            

    private final String strOpenWebCam = ""
            + "def open_camera():\n"
            + "    ctypes.windll.user32.MessageBoxW(0, \"Press ESC to close the web cam\", \"Information\", 1)\n"
            + "    global nTotal;\n"
            + "    global nOpenSuccess;\n"
            + "    global nClosedSuccess;\n"
            + "    global acc;\n"
            + "    x='open'\n"
            + "    capture=cv2.VideoCapture(0)\n"
            + "    while(True):\n"
            + "        start = timeit.default_timer()\n"
            + "        ret, frame = capture.read()\n"
            + "        cv2.imshow('video', frame)\n"
            + "        image = np.resize(frame,(224, 224,3))\n"
            + "        image_array = np.asarray(image)\n"
            + "        normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1\n"
            + "        # Load the image into the array\n"
            + "        data[0] = normalized_image_array\n"
            + "        # run the inference\n"
            + "        prediction = model.predict(data)\n"
            + "        ws.send('class:'+class_names[np.argmax(prediction)])\n"
            + "        stop = timeit.default_timer()\n"
            + "        if cv2.waitKey(2) == 27:\n"
            + "            ws.send('stop')\n"
            + "            break\n"
            + "    capture.release()\n"
            + "    cv2.destroyAllWindows()\n"
            + "open_camera()\n";

    private final String strOfflineTest = ""
            + "nTotal=0;\n"
            + "index=-1\n"
            + "acc=0;\n"
            + "for x in class_names:\n"
            + "    index=index+1\n"
            + "    path=os.path.join(test_path,x)\n"
            + "    for imge in os.listdir(path):\n"
            + "        image = Image.open(os.path.join(path,imge))\n"
            + "        image = image.resize((224, 224))\n"
            + "        image_array = np.asarray(image)\n"
            + "        normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1\n"
            + "#        normalized_image_array = (image_array.astype(np.float32) / 255.0)\n"
            + "        data[0] = normalized_image_array \n"
            + "        start = timeit.default_timer()\n"
            + "        prediction = model.predict(data)\n"
            + "        stop = timeit.default_timer()\n"
            + "        nTotal+=1\n"
            + "        if x==class_names[index] and np.argmax(prediction)==index:\n"
            + "          hist_hit[index]=hist_hit[index]+1\n"
            + "        else:\n"
            + "          hist_error[index]=hist_error[index]+1\n"
            + "        ws.send(''+class_names[np.argmax(prediction)])\n"
            + "acc=sum(hist_hit)*1.0/(sum(hist_hit)+sum(hist_error))\n"
            + "ws.send('offline batch prediction accuracy:'+str(acc))\n"
            + "ws.send('stop')\n";
    

    private final String strPredictOneByOne=""
                            + "ws.send('python client is ready now')\n"
                            + "def predictSingleImage(actual,path):\n"
                            + "     data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32)\n"
                            + "     image = Image.open(path)\n"
                            + "     # Make sure to resize all images to 224, 224 otherwise they won't fit in the array\n"
                            + "     image = image.resize((224, 224))\n"
                            + "     image_array = np.asarray(image)\n"
                            + "     # Normalize the image\n"
                            + "     normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1\n"
                            + "     #normalized_image_array = (image_array.astype(np.float32) / 255.0)\n"
                            + "     # Load the image into the array\n"
                            + "     data[0] = normalized_image_array \n"
                            + "     # run the inference\n"
                            + "     start = timeit.default_timer()\n"
                            + "     prediction = model.predict(data)\n"
                            + "     stop = timeit.default_timer()\n"
                            + "     ws.send(actual+'<->'+str(np.argmax(prediction)))\n"
                            + "def on_message(ws, message):\n"
                            + "    if message=='stop':\n"
                            + "      ws.send('stop')\n"
                            + "      ws.close()\n"
                            + "    else:\n"
                            + "      message=message.split(';')\n"
                            + "      predictSingleImage(message[0],message[1])\n"
                            + "ws = websocket.WebSocketApp('ws://127.0.0.1:8887',on_message = on_message)\n"
                            + "ws.run_forever()\n";
            
           
    String scriptFilePath = "";
    ConfigurationPythonScript config = null;

    @Override
    public void setConfiguration(InterfaceConfiguration cnf) {
        this.config = (ConfigurationPythonScript) cnf;
    }

    @Override
    public void build() {
        String str = "";
        if (config.getLearningMode() == EnumLearningMode.TEST) {
            str = strImportLibrary + "model = tensorflow.keras.models.load_model(r'" + config.getModelPath() + "')\n";
            if (config.getDataSource() == EnumDataSource.CAMERA) {
                str +=  strConnectWebSocket+getClassNames(config.getClassLabels()) + strOpenWebCam;
            } else if (config.getDataSource() == EnumDataSource.IMAGE_FOLDER) {
                File[] dirs = FactoryUtils.getDirectories(config.getTestFolderPath());
                String ek = strConnectWebSocket+"class_names = [";
                for (int i = 0; i < dirs.length; i++) {
                    ek += "'" + dirs[i].getName() + "',";
                }
                ek = ek.substring(0, ek.length() - 1);
                ek = ek + "]\n";
                ek +=     "test_path=r'" + config.getTestFolderPath() + "'\n"
                        + "hist_hit=np.zeros(len(class_names))\n"
                        + "hist_error=np.zeros(len(class_names))\n";

                str += ek + strOfflineTest;
            }else if(config.getDataSource() == EnumDataSource.IMAGE_FILE){
                str += strConnectWebSocket+strPredictOneByOne;
            }
        }
        scriptFilePath = FactoryUtils.currDir + "\\scripts\\python\\tmp.py";
        FactoryUtils.writeToFile(scriptFilePath, str);
    }

    @Override
    public void execute(int port) {
        FactoryUtils.icbf=config.getCall_back();
        new Thread(new Runnable() {
            @Override
            public void run() {
                FactoryUtils.executeCmdCommand("python " + scriptFilePath);
            }
        }).start();
    }

    private String getClassNames(String[] classLabels) {
        String ek = "class_names = [";
        for (int i = 0; i < classLabels.length; i++) {
            ek += "'" + classLabels[i] + "',";
        }
        ek = ek.substring(0, ek.length() - 1);
        ek = ek + "]\n";
        return ek;
    }

}
